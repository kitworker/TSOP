   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"stm32f10x_usart.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  20              	.LC0:
  21 0000 2E2E2F53 		.ascii	"../SPL/src/stm32f10x_usart.c\000"
  21      504C2F73 
  21      72632F73 
  21      746D3332 
  21      66313078 
  22 001d 000000   		.text
  23              		.align	2
  24              		.global	USART_DeInit
  25              		.thumb
  26              		.thumb_func
  28              	USART_DeInit:
  29              	.LFB29:
  30              		.file 1 "../SPL/src/stm32f10x_usart.c"
   1:../SPL/src/stm32f10x_usart.c **** /**
   2:../SPL/src/stm32f10x_usart.c ****   ******************************************************************************
   3:../SPL/src/stm32f10x_usart.c ****   * @file    stm32f10x_usart.c
   4:../SPL/src/stm32f10x_usart.c ****   * @author  MCD Application Team
   5:../SPL/src/stm32f10x_usart.c ****   * @version V3.5.0
   6:../SPL/src/stm32f10x_usart.c ****   * @date    11-March-2011
   7:../SPL/src/stm32f10x_usart.c ****   * @brief   This file provides all the USART firmware functions.
   8:../SPL/src/stm32f10x_usart.c ****   ******************************************************************************
   9:../SPL/src/stm32f10x_usart.c ****   * @attention
  10:../SPL/src/stm32f10x_usart.c ****   *
  11:../SPL/src/stm32f10x_usart.c ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12:../SPL/src/stm32f10x_usart.c ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13:../SPL/src/stm32f10x_usart.c ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  14:../SPL/src/stm32f10x_usart.c ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15:../SPL/src/stm32f10x_usart.c ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16:../SPL/src/stm32f10x_usart.c ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17:../SPL/src/stm32f10x_usart.c ****   *
  18:../SPL/src/stm32f10x_usart.c ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  19:../SPL/src/stm32f10x_usart.c ****   ******************************************************************************
  20:../SPL/src/stm32f10x_usart.c ****   */
  21:../SPL/src/stm32f10x_usart.c **** 
  22:../SPL/src/stm32f10x_usart.c **** /* Includes ------------------------------------------------------------------*/
  23:../SPL/src/stm32f10x_usart.c **** #include "stm32f10x_usart.h"
  24:../SPL/src/stm32f10x_usart.c **** #include "stm32f10x_rcc.h"
  25:../SPL/src/stm32f10x_usart.c **** 
  26:../SPL/src/stm32f10x_usart.c **** /** @addtogroup STM32F10x_StdPeriph_Driver
  27:../SPL/src/stm32f10x_usart.c ****   * @{
  28:../SPL/src/stm32f10x_usart.c ****   */
  29:../SPL/src/stm32f10x_usart.c **** 
  30:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART 
  31:../SPL/src/stm32f10x_usart.c ****   * @brief USART driver modules
  32:../SPL/src/stm32f10x_usart.c ****   * @{
  33:../SPL/src/stm32f10x_usart.c ****   */
  34:../SPL/src/stm32f10x_usart.c **** 
  35:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_TypesDefinitions
  36:../SPL/src/stm32f10x_usart.c ****   * @{
  37:../SPL/src/stm32f10x_usart.c ****   */
  38:../SPL/src/stm32f10x_usart.c **** 
  39:../SPL/src/stm32f10x_usart.c **** /**
  40:../SPL/src/stm32f10x_usart.c ****   * @}
  41:../SPL/src/stm32f10x_usart.c ****   */
  42:../SPL/src/stm32f10x_usart.c **** 
  43:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Defines
  44:../SPL/src/stm32f10x_usart.c ****   * @{
  45:../SPL/src/stm32f10x_usart.c ****   */
  46:../SPL/src/stm32f10x_usart.c **** 
  47:../SPL/src/stm32f10x_usart.c **** #define CR1_UE_Set                ((uint16_t)0x2000)  /*!< USART Enable Mask */
  48:../SPL/src/stm32f10x_usart.c **** #define CR1_UE_Reset              ((uint16_t)0xDFFF)  /*!< USART Disable Mask */
  49:../SPL/src/stm32f10x_usart.c **** 
  50:../SPL/src/stm32f10x_usart.c **** #define CR1_WAKE_Mask             ((uint16_t)0xF7FF)  /*!< USART WakeUp Method Mask */
  51:../SPL/src/stm32f10x_usart.c **** 
  52:../SPL/src/stm32f10x_usart.c **** #define CR1_RWU_Set               ((uint16_t)0x0002)  /*!< USART mute mode Enable Mask */
  53:../SPL/src/stm32f10x_usart.c **** #define CR1_RWU_Reset             ((uint16_t)0xFFFD)  /*!< USART mute mode Enable Mask */
  54:../SPL/src/stm32f10x_usart.c **** #define CR1_SBK_Set               ((uint16_t)0x0001)  /*!< USART Break Character send Mask */
  55:../SPL/src/stm32f10x_usart.c **** #define CR1_CLEAR_Mask            ((uint16_t)0xE9F3)  /*!< USART CR1 Mask */
  56:../SPL/src/stm32f10x_usart.c **** #define CR2_Address_Mask          ((uint16_t)0xFFF0)  /*!< USART address Mask */
  57:../SPL/src/stm32f10x_usart.c **** 
  58:../SPL/src/stm32f10x_usart.c **** #define CR2_LINEN_Set              ((uint16_t)0x4000)  /*!< USART LIN Enable Mask */
  59:../SPL/src/stm32f10x_usart.c **** #define CR2_LINEN_Reset            ((uint16_t)0xBFFF)  /*!< USART LIN Disable Mask */
  60:../SPL/src/stm32f10x_usart.c **** 
  61:../SPL/src/stm32f10x_usart.c **** #define CR2_LBDL_Mask             ((uint16_t)0xFFDF)  /*!< USART LIN Break detection Mask */
  62:../SPL/src/stm32f10x_usart.c **** #define CR2_STOP_CLEAR_Mask       ((uint16_t)0xCFFF)  /*!< USART CR2 STOP Bits Mask */
  63:../SPL/src/stm32f10x_usart.c **** #define CR2_CLOCK_CLEAR_Mask      ((uint16_t)0xF0FF)  /*!< USART CR2 Clock Mask */
  64:../SPL/src/stm32f10x_usart.c **** 
  65:../SPL/src/stm32f10x_usart.c **** #define CR3_SCEN_Set              ((uint16_t)0x0020)  /*!< USART SC Enable Mask */
  66:../SPL/src/stm32f10x_usart.c **** #define CR3_SCEN_Reset            ((uint16_t)0xFFDF)  /*!< USART SC Disable Mask */
  67:../SPL/src/stm32f10x_usart.c **** 
  68:../SPL/src/stm32f10x_usart.c **** #define CR3_NACK_Set              ((uint16_t)0x0010)  /*!< USART SC NACK Enable Mask */
  69:../SPL/src/stm32f10x_usart.c **** #define CR3_NACK_Reset            ((uint16_t)0xFFEF)  /*!< USART SC NACK Disable Mask */
  70:../SPL/src/stm32f10x_usart.c **** 
  71:../SPL/src/stm32f10x_usart.c **** #define CR3_HDSEL_Set             ((uint16_t)0x0008)  /*!< USART Half-Duplex Enable Mask */
  72:../SPL/src/stm32f10x_usart.c **** #define CR3_HDSEL_Reset           ((uint16_t)0xFFF7)  /*!< USART Half-Duplex Disable Mask */
  73:../SPL/src/stm32f10x_usart.c **** 
  74:../SPL/src/stm32f10x_usart.c **** #define CR3_IRLP_Mask             ((uint16_t)0xFFFB)  /*!< USART IrDA LowPower mode Mask */
  75:../SPL/src/stm32f10x_usart.c **** #define CR3_CLEAR_Mask            ((uint16_t)0xFCFF)  /*!< USART CR3 Mask */
  76:../SPL/src/stm32f10x_usart.c **** 
  77:../SPL/src/stm32f10x_usart.c **** #define CR3_IREN_Set              ((uint16_t)0x0002)  /*!< USART IrDA Enable Mask */
  78:../SPL/src/stm32f10x_usart.c **** #define CR3_IREN_Reset            ((uint16_t)0xFFFD)  /*!< USART IrDA Disable Mask */
  79:../SPL/src/stm32f10x_usart.c **** #define GTPR_LSB_Mask             ((uint16_t)0x00FF)  /*!< Guard Time Register LSB Mask */
  80:../SPL/src/stm32f10x_usart.c **** #define GTPR_MSB_Mask             ((uint16_t)0xFF00)  /*!< Guard Time Register MSB Mask */
  81:../SPL/src/stm32f10x_usart.c **** #define IT_Mask                   ((uint16_t)0x001F)  /*!< USART Interrupt Mask */
  82:../SPL/src/stm32f10x_usart.c **** 
  83:../SPL/src/stm32f10x_usart.c **** /* USART OverSampling-8 Mask */
  84:../SPL/src/stm32f10x_usart.c **** #define CR1_OVER8_Set             ((u16)0x8000)  /* USART OVER8 mode Enable Mask */
  85:../SPL/src/stm32f10x_usart.c **** #define CR1_OVER8_Reset           ((u16)0x7FFF)  /* USART OVER8 mode Disable Mask */
  86:../SPL/src/stm32f10x_usart.c **** 
  87:../SPL/src/stm32f10x_usart.c **** /* USART One Bit Sampling Mask */
  88:../SPL/src/stm32f10x_usart.c **** #define CR3_ONEBITE_Set           ((u16)0x0800)  /* USART ONEBITE mode Enable Mask */
  89:../SPL/src/stm32f10x_usart.c **** #define CR3_ONEBITE_Reset         ((u16)0xF7FF)  /* USART ONEBITE mode Disable Mask */
  90:../SPL/src/stm32f10x_usart.c **** 
  91:../SPL/src/stm32f10x_usart.c **** /**
  92:../SPL/src/stm32f10x_usart.c ****   * @}
  93:../SPL/src/stm32f10x_usart.c ****   */
  94:../SPL/src/stm32f10x_usart.c **** 
  95:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Macros
  96:../SPL/src/stm32f10x_usart.c ****   * @{
  97:../SPL/src/stm32f10x_usart.c ****   */
  98:../SPL/src/stm32f10x_usart.c **** 
  99:../SPL/src/stm32f10x_usart.c **** /**
 100:../SPL/src/stm32f10x_usart.c ****   * @}
 101:../SPL/src/stm32f10x_usart.c ****   */
 102:../SPL/src/stm32f10x_usart.c **** 
 103:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Variables
 104:../SPL/src/stm32f10x_usart.c ****   * @{
 105:../SPL/src/stm32f10x_usart.c ****   */
 106:../SPL/src/stm32f10x_usart.c **** 
 107:../SPL/src/stm32f10x_usart.c **** /**
 108:../SPL/src/stm32f10x_usart.c ****   * @}
 109:../SPL/src/stm32f10x_usart.c ****   */
 110:../SPL/src/stm32f10x_usart.c **** 
 111:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_FunctionPrototypes
 112:../SPL/src/stm32f10x_usart.c ****   * @{
 113:../SPL/src/stm32f10x_usart.c ****   */
 114:../SPL/src/stm32f10x_usart.c **** 
 115:../SPL/src/stm32f10x_usart.c **** /**
 116:../SPL/src/stm32f10x_usart.c ****   * @}
 117:../SPL/src/stm32f10x_usart.c ****   */
 118:../SPL/src/stm32f10x_usart.c **** 
 119:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Functions
 120:../SPL/src/stm32f10x_usart.c ****   * @{
 121:../SPL/src/stm32f10x_usart.c ****   */
 122:../SPL/src/stm32f10x_usart.c **** 
 123:../SPL/src/stm32f10x_usart.c **** /**
 124:../SPL/src/stm32f10x_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 125:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 126:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values: 
 127:../SPL/src/stm32f10x_usart.c ****   *      USART1, USART2, USART3, UART4 or UART5.
 128:../SPL/src/stm32f10x_usart.c ****   * @retval None
 129:../SPL/src/stm32f10x_usart.c ****   */
 130:../SPL/src/stm32f10x_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 131:../SPL/src/stm32f10x_usart.c **** {
  31              		.loc 1 131 0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 8
  34              		@ frame_needed = 1, uses_anonymous_args = 0
  35 0000 80B5     		push	{r7, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 8
  38              		.cfi_offset 7, -8
  39              		.cfi_offset 14, -4
  40 0002 82B0     		sub	sp, sp, #8
  41              	.LCFI1:
  42              		.cfi_def_cfa_offset 16
  43 0004 00AF     		add	r7, sp, #0
  44              	.LCFI2:
  45              		.cfi_def_cfa_register 7
  46 0006 7860     		str	r0, [r7, #4]
 132:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 133:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
  47              		.loc 1 133 0
  48 0008 7A68     		ldr	r2, [r7, #4]
  49 000a 384B     		ldr	r3, .L8
  50 000c 9A42     		cmp	r2, r3
  51 000e 14D0     		beq	.L2
  52              		.loc 1 133 0 is_stmt 0 discriminator 1
  53 0010 7A68     		ldr	r2, [r7, #4]
  54 0012 374B     		ldr	r3, .L8+4
  55 0014 9A42     		cmp	r2, r3
  56 0016 10D0     		beq	.L2
  57              		.loc 1 133 0 discriminator 2
  58 0018 7A68     		ldr	r2, [r7, #4]
  59 001a 364B     		ldr	r3, .L8+8
  60 001c 9A42     		cmp	r2, r3
  61 001e 0CD0     		beq	.L2
  62              		.loc 1 133 0 discriminator 3
  63 0020 7A68     		ldr	r2, [r7, #4]
  64 0022 354B     		ldr	r3, .L8+12
  65 0024 9A42     		cmp	r2, r3
  66 0026 08D0     		beq	.L2
  67              		.loc 1 133 0 discriminator 4
  68 0028 7A68     		ldr	r2, [r7, #4]
  69 002a 344B     		ldr	r3, .L8+16
  70 002c 9A42     		cmp	r2, r3
  71 002e 04D0     		beq	.L2
  72              		.loc 1 133 0 discriminator 5
  73 0030 3348     		ldr	r0, .L8+20
  74 0032 4FF08501 		mov	r1, #133
  75 0036 FFF7FEFF 		bl	assert_failed
  76              	.L2:
 134:../SPL/src/stm32f10x_usart.c **** 
 135:../SPL/src/stm32f10x_usart.c ****   if (USARTx == USART1)
  77              		.loc 1 135 0 is_stmt 1
  78 003a 7A68     		ldr	r2, [r7, #4]
  79 003c 2B4B     		ldr	r3, .L8
  80 003e 9A42     		cmp	r2, r3
  81 0040 0CD1     		bne	.L3
 136:../SPL/src/stm32f10x_usart.c ****   {
 137:../SPL/src/stm32f10x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  82              		.loc 1 137 0
  83 0042 4FF48040 		mov	r0, #16384
  84 0046 4FF00101 		mov	r1, #1
  85 004a FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 138:../SPL/src/stm32f10x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  86              		.loc 1 138 0
  87 004e 4FF48040 		mov	r0, #16384
  88 0052 4FF00001 		mov	r1, #0
  89 0056 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  90 005a 42E0     		b	.L1
  91              	.L3:
 139:../SPL/src/stm32f10x_usart.c ****   }
 140:../SPL/src/stm32f10x_usart.c ****   else if (USARTx == USART2)
  92              		.loc 1 140 0
  93 005c 7A68     		ldr	r2, [r7, #4]
  94 005e 244B     		ldr	r3, .L8+4
  95 0060 9A42     		cmp	r2, r3
  96 0062 0CD1     		bne	.L5
 141:../SPL/src/stm32f10x_usart.c ****   {
 142:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  97              		.loc 1 142 0
  98 0064 4FF40030 		mov	r0, #131072
  99 0068 4FF00101 		mov	r1, #1
 100 006c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 143:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 101              		.loc 1 143 0
 102 0070 4FF40030 		mov	r0, #131072
 103 0074 4FF00001 		mov	r1, #0
 104 0078 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 105 007c 31E0     		b	.L1
 106              	.L5:
 144:../SPL/src/stm32f10x_usart.c ****   }
 145:../SPL/src/stm32f10x_usart.c ****   else if (USARTx == USART3)
 107              		.loc 1 145 0
 108 007e 7A68     		ldr	r2, [r7, #4]
 109 0080 1C4B     		ldr	r3, .L8+8
 110 0082 9A42     		cmp	r2, r3
 111 0084 0CD1     		bne	.L6
 146:../SPL/src/stm32f10x_usart.c ****   {
 147:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 112              		.loc 1 147 0
 113 0086 4FF48020 		mov	r0, #262144
 114 008a 4FF00101 		mov	r1, #1
 115 008e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 148:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 116              		.loc 1 148 0
 117 0092 4FF48020 		mov	r0, #262144
 118 0096 4FF00001 		mov	r1, #0
 119 009a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 120 009e 20E0     		b	.L1
 121              	.L6:
 149:../SPL/src/stm32f10x_usart.c ****   }    
 150:../SPL/src/stm32f10x_usart.c ****   else if (USARTx == UART4)
 122              		.loc 1 150 0
 123 00a0 7A68     		ldr	r2, [r7, #4]
 124 00a2 154B     		ldr	r3, .L8+12
 125 00a4 9A42     		cmp	r2, r3
 126 00a6 0CD1     		bne	.L7
 151:../SPL/src/stm32f10x_usart.c ****   {
 152:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 127              		.loc 1 152 0
 128 00a8 4FF40020 		mov	r0, #524288
 129 00ac 4FF00101 		mov	r1, #1
 130 00b0 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 153:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 131              		.loc 1 153 0
 132 00b4 4FF40020 		mov	r0, #524288
 133 00b8 4FF00001 		mov	r1, #0
 134 00bc FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 135 00c0 0FE0     		b	.L1
 136              	.L7:
 154:../SPL/src/stm32f10x_usart.c ****   }    
 155:../SPL/src/stm32f10x_usart.c ****   else
 156:../SPL/src/stm32f10x_usart.c ****   {
 157:../SPL/src/stm32f10x_usart.c ****     if (USARTx == UART5)
 137              		.loc 1 157 0
 138 00c2 7A68     		ldr	r2, [r7, #4]
 139 00c4 0D4B     		ldr	r3, .L8+16
 140 00c6 9A42     		cmp	r2, r3
 141 00c8 0BD1     		bne	.L1
 158:../SPL/src/stm32f10x_usart.c ****     { 
 159:../SPL/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 142              		.loc 1 159 0
 143 00ca 4FF48010 		mov	r0, #1048576
 144 00ce 4FF00101 		mov	r1, #1
 145 00d2 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 160:../SPL/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 146              		.loc 1 160 0
 147 00d6 4FF48010 		mov	r0, #1048576
 148 00da 4FF00001 		mov	r1, #0
 149 00de FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 150              	.L1:
 161:../SPL/src/stm32f10x_usart.c ****     }
 162:../SPL/src/stm32f10x_usart.c ****   }
 163:../SPL/src/stm32f10x_usart.c **** }
 151              		.loc 1 163 0
 152 00e2 07F10807 		add	r7, r7, #8
 153 00e6 BD46     		mov	sp, r7
 154 00e8 80BD     		pop	{r7, pc}
 155              	.L9:
 156 00ea 00BF     		.align	2
 157              	.L8:
 158 00ec 00380140 		.word	1073821696
 159 00f0 00440040 		.word	1073759232
 160 00f4 00480040 		.word	1073760256
 161 00f8 004C0040 		.word	1073761280
 162 00fc 00500040 		.word	1073762304
 163 0100 00000000 		.word	.LC0
 164              		.cfi_endproc
 165              	.LFE29:
 167              		.align	2
 168              		.global	USART_Init
 169              		.thumb
 170              		.thumb_func
 172              	USART_Init:
 173              	.LFB30:
 164:../SPL/src/stm32f10x_usart.c **** 
 165:../SPL/src/stm32f10x_usart.c **** /**
 166:../SPL/src/stm32f10x_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 167:../SPL/src/stm32f10x_usart.c ****   *         parameters in the USART_InitStruct .
 168:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 169:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 170:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 171:../SPL/src/stm32f10x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 172:../SPL/src/stm32f10x_usart.c ****   *         that contains the configuration information for the specified USART 
 173:../SPL/src/stm32f10x_usart.c ****   *         peripheral.
 174:../SPL/src/stm32f10x_usart.c ****   * @retval None
 175:../SPL/src/stm32f10x_usart.c ****   */
 176:../SPL/src/stm32f10x_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 177:../SPL/src/stm32f10x_usart.c **** {
 174              		.loc 1 177 0
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 48
 177              		@ frame_needed = 1, uses_anonymous_args = 0
 178 0104 80B5     		push	{r7, lr}
 179              	.LCFI3:
 180              		.cfi_def_cfa_offset 8
 181              		.cfi_offset 7, -8
 182              		.cfi_offset 14, -4
 183 0106 8CB0     		sub	sp, sp, #48
 184              	.LCFI4:
 185              		.cfi_def_cfa_offset 56
 186 0108 00AF     		add	r7, sp, #0
 187              	.LCFI5:
 188              		.cfi_def_cfa_register 7
 189 010a 7860     		str	r0, [r7, #4]
 190 010c 3960     		str	r1, [r7, #0]
 178:../SPL/src/stm32f10x_usart.c ****   uint32_t tmpreg = 0x00, apbclock = 0x00;
 191              		.loc 1 178 0
 192 010e 4FF00003 		mov	r3, #0
 193 0112 FB62     		str	r3, [r7, #44]
 194 0114 4FF00003 		mov	r3, #0
 195 0118 BB62     		str	r3, [r7, #40]
 179:../SPL/src/stm32f10x_usart.c ****   uint32_t integerdivider = 0x00;
 196              		.loc 1 179 0
 197 011a 4FF00003 		mov	r3, #0
 198 011e 7B62     		str	r3, [r7, #36]
 180:../SPL/src/stm32f10x_usart.c ****   uint32_t fractionaldivider = 0x00;
 199              		.loc 1 180 0
 200 0120 4FF00003 		mov	r3, #0
 201 0124 3B62     		str	r3, [r7, #32]
 181:../SPL/src/stm32f10x_usart.c ****   uint32_t usartxbase = 0;
 202              		.loc 1 181 0
 203 0126 4FF00003 		mov	r3, #0
 204 012a FB61     		str	r3, [r7, #28]
 182:../SPL/src/stm32f10x_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 183:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 184:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 205              		.loc 1 184 0
 206 012c 7A68     		ldr	r2, [r7, #4]
 207 012e 9D4B     		ldr	r3, .L27
 208 0130 9A42     		cmp	r2, r3
 209 0132 14D0     		beq	.L11
 210              		.loc 1 184 0 is_stmt 0 discriminator 1
 211 0134 7A68     		ldr	r2, [r7, #4]
 212 0136 9C4B     		ldr	r3, .L27+4
 213 0138 9A42     		cmp	r2, r3
 214 013a 10D0     		beq	.L11
 215              		.loc 1 184 0 discriminator 2
 216 013c 7A68     		ldr	r2, [r7, #4]
 217 013e 9B4B     		ldr	r3, .L27+8
 218 0140 9A42     		cmp	r2, r3
 219 0142 0CD0     		beq	.L11
 220              		.loc 1 184 0 discriminator 3
 221 0144 7A68     		ldr	r2, [r7, #4]
 222 0146 9A4B     		ldr	r3, .L27+12
 223 0148 9A42     		cmp	r2, r3
 224 014a 08D0     		beq	.L11
 225              		.loc 1 184 0 discriminator 4
 226 014c 7A68     		ldr	r2, [r7, #4]
 227 014e 994B     		ldr	r3, .L27+16
 228 0150 9A42     		cmp	r2, r3
 229 0152 04D0     		beq	.L11
 230              		.loc 1 184 0 discriminator 5
 231 0154 9848     		ldr	r0, .L27+20
 232 0156 4FF0B801 		mov	r1, #184
 233 015a FFF7FEFF 		bl	assert_failed
 234              	.L11:
 185:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 235              		.loc 1 185 0 is_stmt 1
 236 015e 3B68     		ldr	r3, [r7, #0]
 237 0160 1B68     		ldr	r3, [r3, #0]
 238 0162 002B     		cmp	r3, #0
 239 0164 04D0     		beq	.L12
 240              		.loc 1 185 0 is_stmt 0 discriminator 2
 241 0166 3B68     		ldr	r3, [r7, #0]
 242 0168 1A68     		ldr	r2, [r3, #0]
 243 016a 944B     		ldr	r3, .L27+24
 244 016c 9A42     		cmp	r2, r3
 245 016e 04D9     		bls	.L13
 246              	.L12:
 247              		.loc 1 185 0 discriminator 1
 248 0170 9148     		ldr	r0, .L27+20
 249 0172 4FF0B901 		mov	r1, #185
 250 0176 FFF7FEFF 		bl	assert_failed
 251              	.L13:
 186:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 252              		.loc 1 186 0 is_stmt 1
 253 017a 3B68     		ldr	r3, [r7, #0]
 254 017c 9B88     		ldrh	r3, [r3, #4]
 255 017e 002B     		cmp	r3, #0
 256 0180 09D0     		beq	.L14
 257              		.loc 1 186 0 is_stmt 0 discriminator 1
 258 0182 3B68     		ldr	r3, [r7, #0]
 259 0184 9B88     		ldrh	r3, [r3, #4]
 260 0186 B3F5805F 		cmp	r3, #4096
 261 018a 04D0     		beq	.L14
 262              		.loc 1 186 0 discriminator 2
 263 018c 8A48     		ldr	r0, .L27+20
 264 018e 4FF0BA01 		mov	r1, #186
 265 0192 FFF7FEFF 		bl	assert_failed
 266              	.L14:
 187:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 267              		.loc 1 187 0 is_stmt 1
 268 0196 3B68     		ldr	r3, [r7, #0]
 269 0198 DB88     		ldrh	r3, [r3, #6]
 270 019a 002B     		cmp	r3, #0
 271 019c 13D0     		beq	.L15
 272              		.loc 1 187 0 is_stmt 0 discriminator 1
 273 019e 3B68     		ldr	r3, [r7, #0]
 274 01a0 DB88     		ldrh	r3, [r3, #6]
 275 01a2 B3F5805F 		cmp	r3, #4096
 276 01a6 0ED0     		beq	.L15
 277              		.loc 1 187 0 discriminator 2
 278 01a8 3B68     		ldr	r3, [r7, #0]
 279 01aa DB88     		ldrh	r3, [r3, #6]
 280 01ac B3F5005F 		cmp	r3, #8192
 281 01b0 09D0     		beq	.L15
 282              		.loc 1 187 0 discriminator 3
 283 01b2 3B68     		ldr	r3, [r7, #0]
 284 01b4 DB88     		ldrh	r3, [r3, #6]
 285 01b6 B3F5405F 		cmp	r3, #12288
 286 01ba 04D0     		beq	.L15
 287              		.loc 1 187 0 discriminator 4
 288 01bc 7E48     		ldr	r0, .L27+20
 289 01be 4FF0BB01 		mov	r1, #187
 290 01c2 FFF7FEFF 		bl	assert_failed
 291              	.L15:
 188:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 292              		.loc 1 188 0 is_stmt 1
 293 01c6 3B68     		ldr	r3, [r7, #0]
 294 01c8 1B89     		ldrh	r3, [r3, #8]
 295 01ca 002B     		cmp	r3, #0
 296 01cc 0ED0     		beq	.L16
 297              		.loc 1 188 0 is_stmt 0 discriminator 1
 298 01ce 3B68     		ldr	r3, [r7, #0]
 299 01d0 1B89     		ldrh	r3, [r3, #8]
 300 01d2 B3F5806F 		cmp	r3, #1024
 301 01d6 09D0     		beq	.L16
 302              		.loc 1 188 0 discriminator 2
 303 01d8 3B68     		ldr	r3, [r7, #0]
 304 01da 1B89     		ldrh	r3, [r3, #8]
 305 01dc B3F5C06F 		cmp	r3, #1536
 306 01e0 04D0     		beq	.L16
 307              		.loc 1 188 0 discriminator 3
 308 01e2 7548     		ldr	r0, .L27+20
 309 01e4 4FF0BC01 		mov	r1, #188
 310 01e8 FFF7FEFF 		bl	assert_failed
 311              	.L16:
 189:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 312              		.loc 1 189 0 is_stmt 1
 313 01ec 3B68     		ldr	r3, [r7, #0]
 314 01ee 5B89     		ldrh	r3, [r3, #10]
 315 01f0 1A46     		mov	r2, r3
 316 01f2 4FF6F373 		movw	r3, #65523
 317 01f6 1340     		ands	r3, r3, r2
 318 01f8 002B     		cmp	r3, #0
 319 01fa 03D1     		bne	.L17
 320              		.loc 1 189 0 is_stmt 0 discriminator 2
 321 01fc 3B68     		ldr	r3, [r7, #0]
 322 01fe 5B89     		ldrh	r3, [r3, #10]
 323 0200 002B     		cmp	r3, #0
 324 0202 04D1     		bne	.L18
 325              	.L17:
 326              		.loc 1 189 0 discriminator 1
 327 0204 6C48     		ldr	r0, .L27+20
 328 0206 4FF0BD01 		mov	r1, #189
 329 020a FFF7FEFF 		bl	assert_failed
 330              	.L18:
 190:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 331              		.loc 1 190 0 is_stmt 1
 332 020e 3B68     		ldr	r3, [r7, #0]
 333 0210 9B89     		ldrh	r3, [r3, #12]
 334 0212 002B     		cmp	r3, #0
 335 0214 13D0     		beq	.L19
 336              		.loc 1 190 0 is_stmt 0 discriminator 1
 337 0216 3B68     		ldr	r3, [r7, #0]
 338 0218 9B89     		ldrh	r3, [r3, #12]
 339 021a B3F5807F 		cmp	r3, #256
 340 021e 0ED0     		beq	.L19
 341              		.loc 1 190 0 discriminator 2
 342 0220 3B68     		ldr	r3, [r7, #0]
 343 0222 9B89     		ldrh	r3, [r3, #12]
 344 0224 B3F5007F 		cmp	r3, #512
 345 0228 09D0     		beq	.L19
 346              		.loc 1 190 0 discriminator 3
 347 022a 3B68     		ldr	r3, [r7, #0]
 348 022c 9B89     		ldrh	r3, [r3, #12]
 349 022e B3F5407F 		cmp	r3, #768
 350 0232 04D0     		beq	.L19
 351              		.loc 1 190 0 discriminator 4
 352 0234 6048     		ldr	r0, .L27+20
 353 0236 4FF0BE01 		mov	r1, #190
 354 023a FFF7FEFF 		bl	assert_failed
 355              	.L19:
 191:../SPL/src/stm32f10x_usart.c ****   /* The hardware flow control is available only for USART1, USART2 and USART3 */
 192:../SPL/src/stm32f10x_usart.c ****   if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
 356              		.loc 1 192 0 is_stmt 1
 357 023e 3B68     		ldr	r3, [r7, #0]
 358 0240 9B89     		ldrh	r3, [r3, #12]
 359 0242 002B     		cmp	r3, #0
 360 0244 10D0     		beq	.L20
 193:../SPL/src/stm32f10x_usart.c ****   {
 194:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 361              		.loc 1 194 0
 362 0246 7A68     		ldr	r2, [r7, #4]
 363 0248 564B     		ldr	r3, .L27
 364 024a 9A42     		cmp	r2, r3
 365 024c 0CD0     		beq	.L20
 366              		.loc 1 194 0 is_stmt 0 discriminator 1
 367 024e 7A68     		ldr	r2, [r7, #4]
 368 0250 554B     		ldr	r3, .L27+4
 369 0252 9A42     		cmp	r2, r3
 370 0254 08D0     		beq	.L20
 371              		.loc 1 194 0 discriminator 2
 372 0256 7A68     		ldr	r2, [r7, #4]
 373 0258 544B     		ldr	r3, .L27+8
 374 025a 9A42     		cmp	r2, r3
 375 025c 04D0     		beq	.L20
 376              		.loc 1 194 0 discriminator 3
 377 025e 5648     		ldr	r0, .L27+20
 378 0260 4FF0C201 		mov	r1, #194
 379 0264 FFF7FEFF 		bl	assert_failed
 380              	.L20:
 195:../SPL/src/stm32f10x_usart.c ****   }
 196:../SPL/src/stm32f10x_usart.c **** 
 197:../SPL/src/stm32f10x_usart.c ****   usartxbase = (uint32_t)USARTx;
 381              		.loc 1 197 0 is_stmt 1
 382 0268 7B68     		ldr	r3, [r7, #4]
 383 026a FB61     		str	r3, [r7, #28]
 198:../SPL/src/stm32f10x_usart.c **** 
 199:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 200:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR2;
 384              		.loc 1 200 0
 385 026c 7B68     		ldr	r3, [r7, #4]
 386 026e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 387 0270 9BB2     		uxth	r3, r3
 388 0272 FB62     		str	r3, [r7, #44]
 201:../SPL/src/stm32f10x_usart.c ****   /* Clear STOP[13:12] bits */
 202:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR2_STOP_CLEAR_Mask;
 389              		.loc 1 202 0
 390 0274 FA6A     		ldr	r2, [r7, #44]
 391 0276 4CF6FF73 		movw	r3, #53247
 392 027a 1340     		ands	r3, r3, r2
 393 027c FB62     		str	r3, [r7, #44]
 203:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
 204:../SPL/src/stm32f10x_usart.c ****   /* Set STOP[13:12] bits according to USART_StopBits value */
 205:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 394              		.loc 1 205 0
 395 027e 3B68     		ldr	r3, [r7, #0]
 396 0280 DB88     		ldrh	r3, [r3, #6]
 397 0282 FA6A     		ldr	r2, [r7, #44]
 398 0284 1343     		orrs	r3, r3, r2
 399 0286 FB62     		str	r3, [r7, #44]
 206:../SPL/src/stm32f10x_usart.c ****   
 207:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR2 */
 208:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 400              		.loc 1 208 0
 401 0288 FB6A     		ldr	r3, [r7, #44]
 402 028a 9AB2     		uxth	r2, r3
 403 028c 7B68     		ldr	r3, [r7, #4]
 404 028e 1A82     		strh	r2, [r3, #16]	@ movhi
 209:../SPL/src/stm32f10x_usart.c **** 
 210:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR1 Configuration -----------------------*/
 211:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR1;
 405              		.loc 1 211 0
 406 0290 7B68     		ldr	r3, [r7, #4]
 407 0292 9B89     		ldrh	r3, [r3, #12]	@ movhi
 408 0294 9BB2     		uxth	r3, r3
 409 0296 FB62     		str	r3, [r7, #44]
 212:../SPL/src/stm32f10x_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 213:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR1_CLEAR_Mask;
 410              		.loc 1 213 0
 411 0298 FA6A     		ldr	r2, [r7, #44]
 412 029a 4EF6F313 		movw	r3, #59891
 413 029e 1340     		ands	r3, r3, r2
 414 02a0 FB62     		str	r3, [r7, #44]
 214:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Word Length, Parity and mode ----------------------- */
 215:../SPL/src/stm32f10x_usart.c ****   /* Set the M bits according to USART_WordLength value */
 216:../SPL/src/stm32f10x_usart.c ****   /* Set PCE and PS bits according to USART_Parity value */
 217:../SPL/src/stm32f10x_usart.c ****   /* Set TE and RE bits according to USART_Mode value */
 218:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 415              		.loc 1 218 0
 416 02a2 3B68     		ldr	r3, [r7, #0]
 417 02a4 9A88     		ldrh	r2, [r3, #4]
 418 02a6 3B68     		ldr	r3, [r7, #0]
 419 02a8 1B89     		ldrh	r3, [r3, #8]
 420 02aa 1343     		orrs	r3, r3, r2
 421 02ac 9AB2     		uxth	r2, r3
 219:../SPL/src/stm32f10x_usart.c ****             USART_InitStruct->USART_Mode;
 422              		.loc 1 219 0
 423 02ae 3B68     		ldr	r3, [r7, #0]
 424 02b0 5B89     		ldrh	r3, [r3, #10]
 218:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 425              		.loc 1 218 0
 426 02b2 1343     		orrs	r3, r3, r2
 427 02b4 9BB2     		uxth	r3, r3
 428 02b6 FA6A     		ldr	r2, [r7, #44]
 429 02b8 1343     		orrs	r3, r3, r2
 430 02ba FB62     		str	r3, [r7, #44]
 220:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR1 */
 221:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 = (uint16_t)tmpreg;
 431              		.loc 1 221 0
 432 02bc FB6A     		ldr	r3, [r7, #44]
 433 02be 9AB2     		uxth	r2, r3
 434 02c0 7B68     		ldr	r3, [r7, #4]
 435 02c2 9A81     		strh	r2, [r3, #12]	@ movhi
 222:../SPL/src/stm32f10x_usart.c **** 
 223:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR3 Configuration -----------------------*/  
 224:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR3;
 436              		.loc 1 224 0
 437 02c4 7B68     		ldr	r3, [r7, #4]
 438 02c6 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 439 02c8 9BB2     		uxth	r3, r3
 440 02ca FB62     		str	r3, [r7, #44]
 225:../SPL/src/stm32f10x_usart.c ****   /* Clear CTSE and RTSE bits */
 226:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR3_CLEAR_Mask;
 441              		.loc 1 226 0
 442 02cc FA6A     		ldr	r2, [r7, #44]
 443 02ce 4FF6FF43 		movw	r3, #64767
 444 02d2 1340     		ands	r3, r3, r2
 445 02d4 FB62     		str	r3, [r7, #44]
 227:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART HFC -------------------------------------------------*/
 228:../SPL/src/stm32f10x_usart.c ****   /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 229:../SPL/src/stm32f10x_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 446              		.loc 1 229 0
 447 02d6 3B68     		ldr	r3, [r7, #0]
 448 02d8 9B89     		ldrh	r3, [r3, #12]
 449 02da FA6A     		ldr	r2, [r7, #44]
 450 02dc 1343     		orrs	r3, r3, r2
 451 02de FB62     		str	r3, [r7, #44]
 230:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR3 */
 231:../SPL/src/stm32f10x_usart.c ****   USARTx->CR3 = (uint16_t)tmpreg;
 452              		.loc 1 231 0
 453 02e0 FB6A     		ldr	r3, [r7, #44]
 454 02e2 9AB2     		uxth	r2, r3
 455 02e4 7B68     		ldr	r3, [r7, #4]
 456 02e6 9A82     		strh	r2, [r3, #20]	@ movhi
 232:../SPL/src/stm32f10x_usart.c **** 
 233:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART BRR Configuration -----------------------*/
 234:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Baud Rate -------------------------------------------*/
 235:../SPL/src/stm32f10x_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 457              		.loc 1 235 0
 458 02e8 07F10803 		add	r3, r7, #8
 459 02ec 1846     		mov	r0, r3
 460 02ee FFF7FEFF 		bl	RCC_GetClocksFreq
 236:../SPL/src/stm32f10x_usart.c ****   if (usartxbase == USART1_BASE)
 461              		.loc 1 236 0
 462 02f2 FA69     		ldr	r2, [r7, #28]
 463 02f4 2B4B     		ldr	r3, .L27
 464 02f6 9A42     		cmp	r2, r3
 465 02f8 02D1     		bne	.L21
 237:../SPL/src/stm32f10x_usart.c ****   {
 238:../SPL/src/stm32f10x_usart.c ****     apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 466              		.loc 1 238 0
 467 02fa 7B69     		ldr	r3, [r7, #20]
 468 02fc BB62     		str	r3, [r7, #40]
 469 02fe 01E0     		b	.L22
 470              	.L21:
 239:../SPL/src/stm32f10x_usart.c ****   }
 240:../SPL/src/stm32f10x_usart.c ****   else
 241:../SPL/src/stm32f10x_usart.c ****   {
 242:../SPL/src/stm32f10x_usart.c ****     apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 471              		.loc 1 242 0
 472 0300 3B69     		ldr	r3, [r7, #16]
 473 0302 BB62     		str	r3, [r7, #40]
 474              	.L22:
 243:../SPL/src/stm32f10x_usart.c ****   }
 244:../SPL/src/stm32f10x_usart.c ****   
 245:../SPL/src/stm32f10x_usart.c ****   /* Determine the integer part */
 246:../SPL/src/stm32f10x_usart.c ****   if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 475              		.loc 1 246 0
 476 0304 7B68     		ldr	r3, [r7, #4]
 477 0306 9B89     		ldrh	r3, [r3, #12]	@ movhi
 478 0308 9BB2     		uxth	r3, r3
 479 030a 9BB2     		uxth	r3, r3
 480 030c 1BB2     		sxth	r3, r3
 481 030e 002B     		cmp	r3, #0
 482 0310 0FDA     		bge	.L23
 247:../SPL/src/stm32f10x_usart.c ****   {
 248:../SPL/src/stm32f10x_usart.c ****     /* Integer part computing in case Oversampling mode is 8 Samples */
 249:../SPL/src/stm32f10x_usart.c ****     integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 483              		.loc 1 249 0
 484 0312 BA6A     		ldr	r2, [r7, #40]
 485 0314 1346     		mov	r3, r2
 486 0316 4FEA8303 		lsl	r3, r3, #2
 487 031a 9B18     		adds	r3, r3, r2
 488 031c 4FEA8302 		lsl	r2, r3, #2
 489 0320 9A18     		adds	r2, r3, r2
 490 0322 3B68     		ldr	r3, [r7, #0]
 491 0324 1B68     		ldr	r3, [r3, #0]
 492 0326 4FEA4303 		lsl	r3, r3, #1
 493 032a B2FBF3F3 		udiv	r3, r2, r3
 494 032e 7B62     		str	r3, [r7, #36]
 495 0330 0EE0     		b	.L24
 496              	.L23:
 250:../SPL/src/stm32f10x_usart.c ****   }
 251:../SPL/src/stm32f10x_usart.c ****   else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
 252:../SPL/src/stm32f10x_usart.c ****   {
 253:../SPL/src/stm32f10x_usart.c ****     /* Integer part computing in case Oversampling mode is 16 Samples */
 254:../SPL/src/stm32f10x_usart.c ****     integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 497              		.loc 1 254 0
 498 0332 BA6A     		ldr	r2, [r7, #40]
 499 0334 1346     		mov	r3, r2
 500 0336 4FEA8303 		lsl	r3, r3, #2
 501 033a 9B18     		adds	r3, r3, r2
 502 033c 4FEA8302 		lsl	r2, r3, #2
 503 0340 9A18     		adds	r2, r3, r2
 504 0342 3B68     		ldr	r3, [r7, #0]
 505 0344 1B68     		ldr	r3, [r3, #0]
 506 0346 4FEA8303 		lsl	r3, r3, #2
 507 034a B2FBF3F3 		udiv	r3, r2, r3
 508 034e 7B62     		str	r3, [r7, #36]
 509              	.L24:
 255:../SPL/src/stm32f10x_usart.c ****   }
 256:../SPL/src/stm32f10x_usart.c ****   tmpreg = (integerdivider / 100) << 4;
 510              		.loc 1 256 0
 511 0350 7A6A     		ldr	r2, [r7, #36]
 512 0352 1B4B     		ldr	r3, .L27+28
 513 0354 A3FB0213 		umull	r1, r3, r3, r2
 514 0358 4FEA5313 		lsr	r3, r3, #5
 515 035c 4FEA0313 		lsl	r3, r3, #4
 516 0360 FB62     		str	r3, [r7, #44]
 257:../SPL/src/stm32f10x_usart.c **** 
 258:../SPL/src/stm32f10x_usart.c ****   /* Determine the fractional part */
 259:../SPL/src/stm32f10x_usart.c ****   fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 517              		.loc 1 259 0
 518 0362 FB6A     		ldr	r3, [r7, #44]
 519 0364 4FEA1313 		lsr	r3, r3, #4
 520 0368 4FF06402 		mov	r2, #100
 521 036c 02FB03F3 		mul	r3, r2, r3
 522 0370 7A6A     		ldr	r2, [r7, #36]
 523 0372 D31A     		subs	r3, r2, r3
 524 0374 3B62     		str	r3, [r7, #32]
 260:../SPL/src/stm32f10x_usart.c **** 
 261:../SPL/src/stm32f10x_usart.c ****   /* Implement the fractional part in the register */
 262:../SPL/src/stm32f10x_usart.c ****   if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 525              		.loc 1 262 0
 526 0376 7B68     		ldr	r3, [r7, #4]
 527 0378 9B89     		ldrh	r3, [r3, #12]	@ movhi
 528 037a 9BB2     		uxth	r3, r3
 529 037c 9BB2     		uxth	r3, r3
 530 037e 1BB2     		sxth	r3, r3
 531 0380 002B     		cmp	r3, #0
 532 0382 1FDA     		bge	.L25
 263:../SPL/src/stm32f10x_usart.c ****   {
 264:../SPL/src/stm32f10x_usart.c ****     tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 533              		.loc 1 264 0
 534 0384 3B6A     		ldr	r3, [r7, #32]
 535 0386 4FEAC303 		lsl	r3, r3, #3
 536 038a 03F13202 		add	r2, r3, #50
 537 038e 0C4B     		ldr	r3, .L27+28
 538 0390 A3FB0213 		umull	r1, r3, r3, r2
 539 0394 4FEA5313 		lsr	r3, r3, #5
 540 0398 03F00703 		and	r3, r3, #7
 541 039c FA6A     		ldr	r2, [r7, #44]
 542 039e 1343     		orrs	r3, r3, r2
 543 03a0 FB62     		str	r3, [r7, #44]
 544 03a2 1EE0     		b	.L26
 545              	.L28:
 546              		.align	2
 547              	.L27:
 548 03a4 00380140 		.word	1073821696
 549 03a8 00440040 		.word	1073759232
 550 03ac 00480040 		.word	1073760256
 551 03b0 004C0040 		.word	1073761280
 552 03b4 00500040 		.word	1073762304
 553 03b8 00000000 		.word	.LC0
 554 03bc 20AA4400 		.word	4500000
 555 03c0 1F85EB51 		.word	1374389535
 556              	.L25:
 265:../SPL/src/stm32f10x_usart.c ****   }
 266:../SPL/src/stm32f10x_usart.c ****   else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
 267:../SPL/src/stm32f10x_usart.c ****   {
 268:../SPL/src/stm32f10x_usart.c ****     tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 557              		.loc 1 268 0
 558 03c4 3B6A     		ldr	r3, [r7, #32]
 559 03c6 4FEA0313 		lsl	r3, r3, #4
 560 03ca 03F13202 		add	r2, r3, #50
 561 03ce 094B     		ldr	r3, .L29
 562 03d0 A3FB0213 		umull	r1, r3, r3, r2
 563 03d4 4FEA5313 		lsr	r3, r3, #5
 564 03d8 03F00F03 		and	r3, r3, #15
 565 03dc FA6A     		ldr	r2, [r7, #44]
 566 03de 1343     		orrs	r3, r3, r2
 567 03e0 FB62     		str	r3, [r7, #44]
 568              	.L26:
 269:../SPL/src/stm32f10x_usart.c ****   }
 270:../SPL/src/stm32f10x_usart.c ****   
 271:../SPL/src/stm32f10x_usart.c ****   /* Write to USART BRR */
 272:../SPL/src/stm32f10x_usart.c ****   USARTx->BRR = (uint16_t)tmpreg;
 569              		.loc 1 272 0
 570 03e2 FB6A     		ldr	r3, [r7, #44]
 571 03e4 9AB2     		uxth	r2, r3
 572 03e6 7B68     		ldr	r3, [r7, #4]
 573 03e8 1A81     		strh	r2, [r3, #8]	@ movhi
 273:../SPL/src/stm32f10x_usart.c **** }
 574              		.loc 1 273 0
 575 03ea 07F13007 		add	r7, r7, #48
 576 03ee BD46     		mov	sp, r7
 577 03f0 80BD     		pop	{r7, pc}
 578              	.L30:
 579 03f2 00BF     		.align	2
 580              	.L29:
 581 03f4 1F85EB51 		.word	1374389535
 582              		.cfi_endproc
 583              	.LFE30:
 585              		.align	2
 586              		.global	USART_StructInit
 587              		.thumb
 588              		.thumb_func
 590              	USART_StructInit:
 591              	.LFB31:
 274:../SPL/src/stm32f10x_usart.c **** 
 275:../SPL/src/stm32f10x_usart.c **** /**
 276:../SPL/src/stm32f10x_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 277:../SPL/src/stm32f10x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 278:../SPL/src/stm32f10x_usart.c ****   *         which will be initialized.
 279:../SPL/src/stm32f10x_usart.c ****   * @retval None
 280:../SPL/src/stm32f10x_usart.c ****   */
 281:../SPL/src/stm32f10x_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 282:../SPL/src/stm32f10x_usart.c **** {
 592              		.loc 1 282 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 8
 595              		@ frame_needed = 1, uses_anonymous_args = 0
 596              		@ link register save eliminated.
 597 03f8 80B4     		push	{r7}
 598              	.LCFI6:
 599              		.cfi_def_cfa_offset 4
 600              		.cfi_offset 7, -4
 601 03fa 83B0     		sub	sp, sp, #12
 602              	.LCFI7:
 603              		.cfi_def_cfa_offset 16
 604 03fc 00AF     		add	r7, sp, #0
 605              	.LCFI8:
 606              		.cfi_def_cfa_register 7
 607 03fe 7860     		str	r0, [r7, #4]
 283:../SPL/src/stm32f10x_usart.c ****   /* USART_InitStruct members default value */
 284:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 608              		.loc 1 284 0
 609 0400 7B68     		ldr	r3, [r7, #4]
 610 0402 4FF41652 		mov	r2, #9600
 611 0406 1A60     		str	r2, [r3, #0]
 285:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 612              		.loc 1 285 0
 613 0408 7B68     		ldr	r3, [r7, #4]
 614 040a 4FF00002 		mov	r2, #0
 615 040e 9A80     		strh	r2, [r3, #4]	@ movhi
 286:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 616              		.loc 1 286 0
 617 0410 7B68     		ldr	r3, [r7, #4]
 618 0412 4FF00002 		mov	r2, #0
 619 0416 DA80     		strh	r2, [r3, #6]	@ movhi
 287:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 620              		.loc 1 287 0
 621 0418 7B68     		ldr	r3, [r7, #4]
 622 041a 4FF00002 		mov	r2, #0
 623 041e 1A81     		strh	r2, [r3, #8]	@ movhi
 288:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 624              		.loc 1 288 0
 625 0420 7B68     		ldr	r3, [r7, #4]
 626 0422 4FF00C02 		mov	r2, #12
 627 0426 5A81     		strh	r2, [r3, #10]	@ movhi
 289:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 628              		.loc 1 289 0
 629 0428 7B68     		ldr	r3, [r7, #4]
 630 042a 4FF00002 		mov	r2, #0
 631 042e 9A81     		strh	r2, [r3, #12]	@ movhi
 290:../SPL/src/stm32f10x_usart.c **** }
 632              		.loc 1 290 0
 633 0430 07F10C07 		add	r7, r7, #12
 634 0434 BD46     		mov	sp, r7
 635 0436 80BC     		pop	{r7}
 636 0438 7047     		bx	lr
 637              		.cfi_endproc
 638              	.LFE31:
 640 043a 00BF     		.align	2
 641              		.global	USART_ClockInit
 642              		.thumb
 643              		.thumb_func
 645              	USART_ClockInit:
 646              	.LFB32:
 291:../SPL/src/stm32f10x_usart.c **** 
 292:../SPL/src/stm32f10x_usart.c **** /**
 293:../SPL/src/stm32f10x_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the 
 294:../SPL/src/stm32f10x_usart.c ****   *          specified parameters in the USART_ClockInitStruct .
 295:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
 296:../SPL/src/stm32f10x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 297:../SPL/src/stm32f10x_usart.c ****   *         structure that contains the configuration information for the specified 
 298:../SPL/src/stm32f10x_usart.c ****   *         USART peripheral.  
 299:../SPL/src/stm32f10x_usart.c ****   * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
 300:../SPL/src/stm32f10x_usart.c ****   * @retval None
 301:../SPL/src/stm32f10x_usart.c ****   */
 302:../SPL/src/stm32f10x_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 303:../SPL/src/stm32f10x_usart.c **** {
 647              		.loc 1 303 0
 648              		.cfi_startproc
 649              		@ args = 0, pretend = 0, frame = 16
 650              		@ frame_needed = 1, uses_anonymous_args = 0
 651 043c 80B5     		push	{r7, lr}
 652              	.LCFI9:
 653              		.cfi_def_cfa_offset 8
 654              		.cfi_offset 7, -8
 655              		.cfi_offset 14, -4
 656 043e 84B0     		sub	sp, sp, #16
 657              	.LCFI10:
 658              		.cfi_def_cfa_offset 24
 659 0440 00AF     		add	r7, sp, #0
 660              	.LCFI11:
 661              		.cfi_def_cfa_register 7
 662 0442 7860     		str	r0, [r7, #4]
 663 0444 3960     		str	r1, [r7, #0]
 304:../SPL/src/stm32f10x_usart.c ****   uint32_t tmpreg = 0x00;
 664              		.loc 1 304 0
 665 0446 4FF00003 		mov	r3, #0
 666 044a FB60     		str	r3, [r7, #12]
 305:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 306:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 667              		.loc 1 306 0
 668 044c 7A68     		ldr	r2, [r7, #4]
 669 044e 354B     		ldr	r3, .L38
 670 0450 9A42     		cmp	r2, r3
 671 0452 0CD0     		beq	.L33
 672              		.loc 1 306 0 is_stmt 0 discriminator 1
 673 0454 7A68     		ldr	r2, [r7, #4]
 674 0456 344B     		ldr	r3, .L38+4
 675 0458 9A42     		cmp	r2, r3
 676 045a 08D0     		beq	.L33
 677              		.loc 1 306 0 discriminator 2
 678 045c 7A68     		ldr	r2, [r7, #4]
 679 045e 334B     		ldr	r3, .L38+8
 680 0460 9A42     		cmp	r2, r3
 681 0462 04D0     		beq	.L33
 682              		.loc 1 306 0 discriminator 3
 683 0464 3248     		ldr	r0, .L38+12
 684 0466 4FF49971 		mov	r1, #306
 685 046a FFF7FEFF 		bl	assert_failed
 686              	.L33:
 307:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 687              		.loc 1 307 0 is_stmt 1
 688 046e 3B68     		ldr	r3, [r7, #0]
 689 0470 1B88     		ldrh	r3, [r3, #0]
 690 0472 002B     		cmp	r3, #0
 691 0474 09D0     		beq	.L34
 692              		.loc 1 307 0 is_stmt 0 discriminator 1
 693 0476 3B68     		ldr	r3, [r7, #0]
 694 0478 1B88     		ldrh	r3, [r3, #0]
 695 047a B3F5006F 		cmp	r3, #2048
 696 047e 04D0     		beq	.L34
 697              		.loc 1 307 0 discriminator 2
 698 0480 2B48     		ldr	r0, .L38+12
 699 0482 40F23311 		movw	r1, #307
 700 0486 FFF7FEFF 		bl	assert_failed
 701              	.L34:
 308:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 702              		.loc 1 308 0 is_stmt 1
 703 048a 3B68     		ldr	r3, [r7, #0]
 704 048c 5B88     		ldrh	r3, [r3, #2]
 705 048e 002B     		cmp	r3, #0
 706 0490 09D0     		beq	.L35
 707              		.loc 1 308 0 is_stmt 0 discriminator 1
 708 0492 3B68     		ldr	r3, [r7, #0]
 709 0494 5B88     		ldrh	r3, [r3, #2]
 710 0496 B3F5806F 		cmp	r3, #1024
 711 049a 04D0     		beq	.L35
 712              		.loc 1 308 0 discriminator 2
 713 049c 2448     		ldr	r0, .L38+12
 714 049e 4FF49A71 		mov	r1, #308
 715 04a2 FFF7FEFF 		bl	assert_failed
 716              	.L35:
 309:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 717              		.loc 1 309 0 is_stmt 1
 718 04a6 3B68     		ldr	r3, [r7, #0]
 719 04a8 9B88     		ldrh	r3, [r3, #4]
 720 04aa 002B     		cmp	r3, #0
 721 04ac 09D0     		beq	.L36
 722              		.loc 1 309 0 is_stmt 0 discriminator 1
 723 04ae 3B68     		ldr	r3, [r7, #0]
 724 04b0 9B88     		ldrh	r3, [r3, #4]
 725 04b2 B3F5007F 		cmp	r3, #512
 726 04b6 04D0     		beq	.L36
 727              		.loc 1 309 0 discriminator 2
 728 04b8 1D48     		ldr	r0, .L38+12
 729 04ba 40F23511 		movw	r1, #309
 730 04be FFF7FEFF 		bl	assert_failed
 731              	.L36:
 310:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 732              		.loc 1 310 0 is_stmt 1
 733 04c2 3B68     		ldr	r3, [r7, #0]
 734 04c4 DB88     		ldrh	r3, [r3, #6]
 735 04c6 002B     		cmp	r3, #0
 736 04c8 09D0     		beq	.L37
 737              		.loc 1 310 0 is_stmt 0 discriminator 1
 738 04ca 3B68     		ldr	r3, [r7, #0]
 739 04cc DB88     		ldrh	r3, [r3, #6]
 740 04ce B3F5807F 		cmp	r3, #256
 741 04d2 04D0     		beq	.L37
 742              		.loc 1 310 0 discriminator 2
 743 04d4 1648     		ldr	r0, .L38+12
 744 04d6 4FF49B71 		mov	r1, #310
 745 04da FFF7FEFF 		bl	assert_failed
 746              	.L37:
 311:../SPL/src/stm32f10x_usart.c ****   
 312:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 313:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR2;
 747              		.loc 1 313 0 is_stmt 1
 748 04de 7B68     		ldr	r3, [r7, #4]
 749 04e0 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 750 04e2 9BB2     		uxth	r3, r3
 751 04e4 FB60     		str	r3, [r7, #12]
 314:../SPL/src/stm32f10x_usart.c ****   /* Clear CLKEN, CPOL, CPHA and LBCL bits */
 315:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR2_CLOCK_CLEAR_Mask;
 752              		.loc 1 315 0
 753 04e6 FA68     		ldr	r2, [r7, #12]
 754 04e8 4FF2FF03 		movw	r3, #61695
 755 04ec 1340     		ands	r3, r3, r2
 756 04ee FB60     		str	r3, [r7, #12]
 316:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
 317:../SPL/src/stm32f10x_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 318:../SPL/src/stm32f10x_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 319:../SPL/src/stm32f10x_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 320:../SPL/src/stm32f10x_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 321:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 757              		.loc 1 321 0
 758 04f0 3B68     		ldr	r3, [r7, #0]
 759 04f2 1A88     		ldrh	r2, [r3, #0]
 760 04f4 3B68     		ldr	r3, [r7, #0]
 761 04f6 5B88     		ldrh	r3, [r3, #2]
 322:../SPL/src/stm32f10x_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 762              		.loc 1 322 0
 763 04f8 1343     		orrs	r3, r3, r2
 764 04fa 9AB2     		uxth	r2, r3
 765 04fc 3B68     		ldr	r3, [r7, #0]
 766 04fe 9B88     		ldrh	r3, [r3, #4]
 767 0500 1343     		orrs	r3, r3, r2
 768 0502 9AB2     		uxth	r2, r3
 769 0504 3B68     		ldr	r3, [r7, #0]
 770 0506 DB88     		ldrh	r3, [r3, #6]
 771 0508 1343     		orrs	r3, r3, r2
 772 050a 9BB2     		uxth	r3, r3
 321:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 773              		.loc 1 321 0
 774 050c FA68     		ldr	r2, [r7, #12]
 775 050e 1343     		orrs	r3, r3, r2
 776 0510 FB60     		str	r3, [r7, #12]
 323:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR2 */
 324:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 777              		.loc 1 324 0
 778 0512 FB68     		ldr	r3, [r7, #12]
 779 0514 9AB2     		uxth	r2, r3
 780 0516 7B68     		ldr	r3, [r7, #4]
 781 0518 1A82     		strh	r2, [r3, #16]	@ movhi
 325:../SPL/src/stm32f10x_usart.c **** }
 782              		.loc 1 325 0
 783 051a 07F11007 		add	r7, r7, #16
 784 051e BD46     		mov	sp, r7
 785 0520 80BD     		pop	{r7, pc}
 786              	.L39:
 787 0522 00BF     		.align	2
 788              	.L38:
 789 0524 00380140 		.word	1073821696
 790 0528 00440040 		.word	1073759232
 791 052c 00480040 		.word	1073760256
 792 0530 00000000 		.word	.LC0
 793              		.cfi_endproc
 794              	.LFE32:
 796              		.align	2
 797              		.global	USART_ClockStructInit
 798              		.thumb
 799              		.thumb_func
 801              	USART_ClockStructInit:
 802              	.LFB33:
 326:../SPL/src/stm32f10x_usart.c **** 
 327:../SPL/src/stm32f10x_usart.c **** /**
 328:../SPL/src/stm32f10x_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 329:../SPL/src/stm32f10x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 330:../SPL/src/stm32f10x_usart.c ****   *         structure which will be initialized.
 331:../SPL/src/stm32f10x_usart.c ****   * @retval None
 332:../SPL/src/stm32f10x_usart.c ****   */
 333:../SPL/src/stm32f10x_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 334:../SPL/src/stm32f10x_usart.c **** {
 803              		.loc 1 334 0
 804              		.cfi_startproc
 805              		@ args = 0, pretend = 0, frame = 8
 806              		@ frame_needed = 1, uses_anonymous_args = 0
 807              		@ link register save eliminated.
 808 0534 80B4     		push	{r7}
 809              	.LCFI12:
 810              		.cfi_def_cfa_offset 4
 811              		.cfi_offset 7, -4
 812 0536 83B0     		sub	sp, sp, #12
 813              	.LCFI13:
 814              		.cfi_def_cfa_offset 16
 815 0538 00AF     		add	r7, sp, #0
 816              	.LCFI14:
 817              		.cfi_def_cfa_register 7
 818 053a 7860     		str	r0, [r7, #4]
 335:../SPL/src/stm32f10x_usart.c ****   /* USART_ClockInitStruct members default value */
 336:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 819              		.loc 1 336 0
 820 053c 7B68     		ldr	r3, [r7, #4]
 821 053e 4FF00002 		mov	r2, #0
 822 0542 1A80     		strh	r2, [r3, #0]	@ movhi
 337:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 823              		.loc 1 337 0
 824 0544 7B68     		ldr	r3, [r7, #4]
 825 0546 4FF00002 		mov	r2, #0
 826 054a 5A80     		strh	r2, [r3, #2]	@ movhi
 338:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 827              		.loc 1 338 0
 828 054c 7B68     		ldr	r3, [r7, #4]
 829 054e 4FF00002 		mov	r2, #0
 830 0552 9A80     		strh	r2, [r3, #4]	@ movhi
 339:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 831              		.loc 1 339 0
 832 0554 7B68     		ldr	r3, [r7, #4]
 833 0556 4FF00002 		mov	r2, #0
 834 055a DA80     		strh	r2, [r3, #6]	@ movhi
 340:../SPL/src/stm32f10x_usart.c **** }
 835              		.loc 1 340 0
 836 055c 07F10C07 		add	r7, r7, #12
 837 0560 BD46     		mov	sp, r7
 838 0562 80BC     		pop	{r7}
 839 0564 7047     		bx	lr
 840              		.cfi_endproc
 841              	.LFE33:
 843 0566 00BF     		.align	2
 844              		.global	USART_Cmd
 845              		.thumb
 846              		.thumb_func
 848              	USART_Cmd:
 849              	.LFB34:
 341:../SPL/src/stm32f10x_usart.c **** 
 342:../SPL/src/stm32f10x_usart.c **** /**
 343:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 344:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 345:../SPL/src/stm32f10x_usart.c ****   *         This parameter can be one of the following values:
 346:../SPL/src/stm32f10x_usart.c ****   *           USART1, USART2, USART3, UART4 or UART5.
 347:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 348:../SPL/src/stm32f10x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 349:../SPL/src/stm32f10x_usart.c ****   * @retval None
 350:../SPL/src/stm32f10x_usart.c ****   */
 351:../SPL/src/stm32f10x_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 352:../SPL/src/stm32f10x_usart.c **** {
 850              		.loc 1 352 0
 851              		.cfi_startproc
 852              		@ args = 0, pretend = 0, frame = 8
 853              		@ frame_needed = 1, uses_anonymous_args = 0
 854 0568 80B5     		push	{r7, lr}
 855              	.LCFI15:
 856              		.cfi_def_cfa_offset 8
 857              		.cfi_offset 7, -8
 858              		.cfi_offset 14, -4
 859 056a 82B0     		sub	sp, sp, #8
 860              	.LCFI16:
 861              		.cfi_def_cfa_offset 16
 862 056c 00AF     		add	r7, sp, #0
 863              	.LCFI17:
 864              		.cfi_def_cfa_register 7
 865 056e 7860     		str	r0, [r7, #4]
 866 0570 0B46     		mov	r3, r1
 867 0572 FB70     		strb	r3, [r7, #3]
 353:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 354:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 868              		.loc 1 354 0
 869 0574 7A68     		ldr	r2, [r7, #4]
 870 0576 1D4B     		ldr	r3, .L46
 871 0578 9A42     		cmp	r2, r3
 872 057a 14D0     		beq	.L42
 873              		.loc 1 354 0 is_stmt 0 discriminator 1
 874 057c 7A68     		ldr	r2, [r7, #4]
 875 057e 1C4B     		ldr	r3, .L46+4
 876 0580 9A42     		cmp	r2, r3
 877 0582 10D0     		beq	.L42
 878              		.loc 1 354 0 discriminator 2
 879 0584 7A68     		ldr	r2, [r7, #4]
 880 0586 1B4B     		ldr	r3, .L46+8
 881 0588 9A42     		cmp	r2, r3
 882 058a 0CD0     		beq	.L42
 883              		.loc 1 354 0 discriminator 3
 884 058c 7A68     		ldr	r2, [r7, #4]
 885 058e 1A4B     		ldr	r3, .L46+12
 886 0590 9A42     		cmp	r2, r3
 887 0592 08D0     		beq	.L42
 888              		.loc 1 354 0 discriminator 4
 889 0594 7A68     		ldr	r2, [r7, #4]
 890 0596 194B     		ldr	r3, .L46+16
 891 0598 9A42     		cmp	r2, r3
 892 059a 04D0     		beq	.L42
 893              		.loc 1 354 0 discriminator 5
 894 059c 1848     		ldr	r0, .L46+20
 895 059e 4FF4B171 		mov	r1, #354
 896 05a2 FFF7FEFF 		bl	assert_failed
 897              	.L42:
 355:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 898              		.loc 1 355 0 is_stmt 1
 899 05a6 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 900 05a8 002B     		cmp	r3, #0
 901 05aa 07D0     		beq	.L43
 902              		.loc 1 355 0 is_stmt 0 discriminator 1
 903 05ac FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 904 05ae 012B     		cmp	r3, #1
 905 05b0 04D0     		beq	.L43
 906              		.loc 1 355 0 discriminator 2
 907 05b2 1348     		ldr	r0, .L46+20
 908 05b4 40F26311 		movw	r1, #355
 909 05b8 FFF7FEFF 		bl	assert_failed
 910              	.L43:
 356:../SPL/src/stm32f10x_usart.c ****   
 357:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 911              		.loc 1 357 0 is_stmt 1
 912 05bc FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 913 05be 002B     		cmp	r3, #0
 914 05c0 08D0     		beq	.L44
 358:../SPL/src/stm32f10x_usart.c ****   {
 359:../SPL/src/stm32f10x_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 360:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_UE_Set;
 915              		.loc 1 360 0
 916 05c2 7B68     		ldr	r3, [r7, #4]
 917 05c4 9B89     		ldrh	r3, [r3, #12]	@ movhi
 918 05c6 9BB2     		uxth	r3, r3
 919 05c8 43F40053 		orr	r3, r3, #8192
 920 05cc 9AB2     		uxth	r2, r3
 921 05ce 7B68     		ldr	r3, [r7, #4]
 922 05d0 9A81     		strh	r2, [r3, #12]	@ movhi
 923 05d2 07E0     		b	.L41
 924              	.L44:
 361:../SPL/src/stm32f10x_usart.c ****   }
 362:../SPL/src/stm32f10x_usart.c ****   else
 363:../SPL/src/stm32f10x_usart.c ****   {
 364:../SPL/src/stm32f10x_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 365:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_UE_Reset;
 925              		.loc 1 365 0
 926 05d4 7B68     		ldr	r3, [r7, #4]
 927 05d6 9B89     		ldrh	r3, [r3, #12]	@ movhi
 928 05d8 9BB2     		uxth	r3, r3
 929 05da 23F40053 		bic	r3, r3, #8192
 930 05de 9AB2     		uxth	r2, r3
 931 05e0 7B68     		ldr	r3, [r7, #4]
 932 05e2 9A81     		strh	r2, [r3, #12]	@ movhi
 933              	.L41:
 366:../SPL/src/stm32f10x_usart.c ****   }
 367:../SPL/src/stm32f10x_usart.c **** }
 934              		.loc 1 367 0
 935 05e4 07F10807 		add	r7, r7, #8
 936 05e8 BD46     		mov	sp, r7
 937 05ea 80BD     		pop	{r7, pc}
 938              	.L47:
 939              		.align	2
 940              	.L46:
 941 05ec 00380140 		.word	1073821696
 942 05f0 00440040 		.word	1073759232
 943 05f4 00480040 		.word	1073760256
 944 05f8 004C0040 		.word	1073761280
 945 05fc 00500040 		.word	1073762304
 946 0600 00000000 		.word	.LC0
 947              		.cfi_endproc
 948              	.LFE34:
 950              		.align	2
 951              		.global	USART_ITConfig
 952              		.thumb
 953              		.thumb_func
 955              	USART_ITConfig:
 956              	.LFB35:
 368:../SPL/src/stm32f10x_usart.c **** 
 369:../SPL/src/stm32f10x_usart.c **** /**
 370:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
 371:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 372:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 373:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 374:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
 375:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 376:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
 377:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_LBD:  LIN Break detection interrupt
 378:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TXE:  Transmit Data Register empty interrupt
 379:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TC:   Transmission complete interrupt
 380:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
 381:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_IDLE: Idle line detection interrupt
 382:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_PE:   Parity Error interrupt
 383:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
 384:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
 385:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 386:../SPL/src/stm32f10x_usart.c ****   * @retval None
 387:../SPL/src/stm32f10x_usart.c ****   */
 388:../SPL/src/stm32f10x_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
 389:../SPL/src/stm32f10x_usart.c **** {
 957              		.loc 1 389 0
 958              		.cfi_startproc
 959              		@ args = 0, pretend = 0, frame = 24
 960              		@ frame_needed = 1, uses_anonymous_args = 0
 961 0604 80B5     		push	{r7, lr}
 962              	.LCFI18:
 963              		.cfi_def_cfa_offset 8
 964              		.cfi_offset 7, -8
 965              		.cfi_offset 14, -4
 966 0606 86B0     		sub	sp, sp, #24
 967              	.LCFI19:
 968              		.cfi_def_cfa_offset 32
 969 0608 00AF     		add	r7, sp, #0
 970              	.LCFI20:
 971              		.cfi_def_cfa_register 7
 972 060a 7860     		str	r0, [r7, #4]
 973 060c 1346     		mov	r3, r2
 974 060e 0A46     		mov	r2, r1	@ movhi
 975 0610 7A80     		strh	r2, [r7, #2]	@ movhi
 976 0612 7B70     		strb	r3, [r7, #1]
 390:../SPL/src/stm32f10x_usart.c ****   uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 977              		.loc 1 390 0
 978 0614 4FF00003 		mov	r3, #0
 979 0618 3B61     		str	r3, [r7, #16]
 980 061a 4FF00003 		mov	r3, #0
 981 061e FB60     		str	r3, [r7, #12]
 982 0620 4FF00003 		mov	r3, #0
 983 0624 BB60     		str	r3, [r7, #8]
 391:../SPL/src/stm32f10x_usart.c ****   uint32_t usartxbase = 0x00;
 984              		.loc 1 391 0
 985 0626 4FF00003 		mov	r3, #0
 986 062a 7B61     		str	r3, [r7, #20]
 392:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 393:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 987              		.loc 1 393 0
 988 062c 7A68     		ldr	r2, [r7, #4]
 989 062e 4F4B     		ldr	r3, .L58
 990 0630 9A42     		cmp	r2, r3
 991 0632 14D0     		beq	.L49
 992              		.loc 1 393 0 is_stmt 0 discriminator 1
 993 0634 7A68     		ldr	r2, [r7, #4]
 994 0636 4E4B     		ldr	r3, .L58+4
 995 0638 9A42     		cmp	r2, r3
 996 063a 10D0     		beq	.L49
 997              		.loc 1 393 0 discriminator 2
 998 063c 7A68     		ldr	r2, [r7, #4]
 999 063e 4D4B     		ldr	r3, .L58+8
 1000 0640 9A42     		cmp	r2, r3
 1001 0642 0CD0     		beq	.L49
 1002              		.loc 1 393 0 discriminator 3
 1003 0644 7A68     		ldr	r2, [r7, #4]
 1004 0646 4C4B     		ldr	r3, .L58+12
 1005 0648 9A42     		cmp	r2, r3
 1006 064a 08D0     		beq	.L49
 1007              		.loc 1 393 0 discriminator 4
 1008 064c 7A68     		ldr	r2, [r7, #4]
 1009 064e 4B4B     		ldr	r3, .L58+16
 1010 0650 9A42     		cmp	r2, r3
 1011 0652 04D0     		beq	.L49
 1012              		.loc 1 393 0 discriminator 5
 1013 0654 4A48     		ldr	r0, .L58+20
 1014 0656 40F28911 		movw	r1, #393
 1015 065a FFF7FEFF 		bl	assert_failed
 1016              	.L49:
 394:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
 1017              		.loc 1 394 0 is_stmt 1
 1018 065e 7B88     		ldrh	r3, [r7, #2]
 1019 0660 282B     		cmp	r3, #40
 1020 0662 25D0     		beq	.L50
 1021              		.loc 1 394 0 is_stmt 0 discriminator 1
 1022 0664 7A88     		ldrh	r2, [r7, #2]
 1023 0666 40F22773 		movw	r3, #1831
 1024 066a 9A42     		cmp	r2, r3
 1025 066c 20D0     		beq	.L50
 1026              		.loc 1 394 0 discriminator 2
 1027 066e 7A88     		ldrh	r2, [r7, #2]
 1028 0670 40F22663 		movw	r3, #1574
 1029 0674 9A42     		cmp	r2, r3
 1030 0676 1BD0     		beq	.L50
 1031              		.loc 1 394 0 discriminator 3
 1032 0678 7A88     		ldrh	r2, [r7, #2]
 1033 067a 40F22553 		movw	r3, #1317
 1034 067e 9A42     		cmp	r2, r3
 1035 0680 16D0     		beq	.L50
 1036              		.loc 1 394 0 discriminator 4
 1037 0682 7A88     		ldrh	r2, [r7, #2]
 1038 0684 40F22443 		movw	r3, #1060
 1039 0688 9A42     		cmp	r2, r3
 1040 068a 11D0     		beq	.L50
 1041              		.loc 1 394 0 discriminator 5
 1042 068c 7A88     		ldrh	r2, [r7, #2]
 1043 068e 40F64603 		movw	r3, #2118
 1044 0692 9A42     		cmp	r2, r3
 1045 0694 0CD0     		beq	.L50
 1046              		.loc 1 394 0 discriminator 6
 1047 0696 7A88     		ldrh	r2, [r7, #2]
 1048 0698 40F66A13 		movw	r3, #2410
 1049 069c 9A42     		cmp	r2, r3
 1050 069e 07D0     		beq	.L50
 1051              		.loc 1 394 0 discriminator 7
 1052 06a0 7B88     		ldrh	r3, [r7, #2]
 1053 06a2 602B     		cmp	r3, #96
 1054 06a4 04D0     		beq	.L50
 1055              		.loc 1 394 0 discriminator 8
 1056 06a6 3648     		ldr	r0, .L58+20
 1057 06a8 4FF4C571 		mov	r1, #394
 1058 06ac FFF7FEFF 		bl	assert_failed
 1059              	.L50:
 395:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 1060              		.loc 1 395 0 is_stmt 1
 1061 06b0 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1062 06b2 002B     		cmp	r3, #0
 1063 06b4 07D0     		beq	.L51
 1064              		.loc 1 395 0 is_stmt 0 discriminator 1
 1065 06b6 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1066 06b8 012B     		cmp	r3, #1
 1067 06ba 04D0     		beq	.L51
 1068              		.loc 1 395 0 discriminator 2
 1069 06bc 3048     		ldr	r0, .L58+20
 1070 06be 40F28B11 		movw	r1, #395
 1071 06c2 FFF7FEFF 		bl	assert_failed
 1072              	.L51:
 396:../SPL/src/stm32f10x_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
 397:../SPL/src/stm32f10x_usart.c ****   if (USART_IT == USART_IT_CTS)
 1073              		.loc 1 397 0 is_stmt 1
 1074 06c6 7A88     		ldrh	r2, [r7, #2]
 1075 06c8 40F66A13 		movw	r3, #2410
 1076 06cc 9A42     		cmp	r2, r3
 1077 06ce 10D1     		bne	.L52
 398:../SPL/src/stm32f10x_usart.c ****   {
 399:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 1078              		.loc 1 399 0
 1079 06d0 7A68     		ldr	r2, [r7, #4]
 1080 06d2 264B     		ldr	r3, .L58
 1081 06d4 9A42     		cmp	r2, r3
 1082 06d6 0CD0     		beq	.L52
 1083              		.loc 1 399 0 is_stmt 0 discriminator 1
 1084 06d8 7A68     		ldr	r2, [r7, #4]
 1085 06da 254B     		ldr	r3, .L58+4
 1086 06dc 9A42     		cmp	r2, r3
 1087 06de 08D0     		beq	.L52
 1088              		.loc 1 399 0 discriminator 2
 1089 06e0 7A68     		ldr	r2, [r7, #4]
 1090 06e2 244B     		ldr	r3, .L58+8
 1091 06e4 9A42     		cmp	r2, r3
 1092 06e6 04D0     		beq	.L52
 1093              		.loc 1 399 0 discriminator 3
 1094 06e8 2548     		ldr	r0, .L58+20
 1095 06ea 40F28F11 		movw	r1, #399
 1096 06ee FFF7FEFF 		bl	assert_failed
 1097              	.L52:
 400:../SPL/src/stm32f10x_usart.c ****   }   
 401:../SPL/src/stm32f10x_usart.c ****   
 402:../SPL/src/stm32f10x_usart.c ****   usartxbase = (uint32_t)USARTx;
 1098              		.loc 1 402 0 is_stmt 1
 1099 06f2 7B68     		ldr	r3, [r7, #4]
 1100 06f4 7B61     		str	r3, [r7, #20]
 403:../SPL/src/stm32f10x_usart.c **** 
 404:../SPL/src/stm32f10x_usart.c ****   /* Get the USART register index */
 405:../SPL/src/stm32f10x_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1101              		.loc 1 405 0
 1102 06f6 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1103 06f8 DBB2     		uxtb	r3, r3
 1104 06fa 4FEA5313 		lsr	r3, r3, #5
 1105 06fe DBB2     		uxtb	r3, r3
 1106 0700 3B61     		str	r3, [r7, #16]
 406:../SPL/src/stm32f10x_usart.c **** 
 407:../SPL/src/stm32f10x_usart.c ****   /* Get the interrupt position */
 408:../SPL/src/stm32f10x_usart.c ****   itpos = USART_IT & IT_Mask;
 1107              		.loc 1 408 0
 1108 0702 7B88     		ldrh	r3, [r7, #2]
 1109 0704 03F01F03 		and	r3, r3, #31
 1110 0708 FB60     		str	r3, [r7, #12]
 409:../SPL/src/stm32f10x_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 1111              		.loc 1 409 0
 1112 070a FB68     		ldr	r3, [r7, #12]
 1113 070c 4FF00102 		mov	r2, #1
 1114 0710 02FA03F3 		lsl	r3, r2, r3
 1115 0714 BB60     		str	r3, [r7, #8]
 410:../SPL/src/stm32f10x_usart.c ****     
 411:../SPL/src/stm32f10x_usart.c ****   if (usartreg == 0x01) /* The IT is in CR1 register */
 1116              		.loc 1 411 0
 1117 0716 3B69     		ldr	r3, [r7, #16]
 1118 0718 012B     		cmp	r3, #1
 1119 071a 04D1     		bne	.L53
 412:../SPL/src/stm32f10x_usart.c ****   {
 413:../SPL/src/stm32f10x_usart.c ****     usartxbase += 0x0C;
 1120              		.loc 1 413 0
 1121 071c 7B69     		ldr	r3, [r7, #20]
 1122 071e 03F10C03 		add	r3, r3, #12
 1123 0722 7B61     		str	r3, [r7, #20]
 1124 0724 0BE0     		b	.L54
 1125              	.L53:
 414:../SPL/src/stm32f10x_usart.c ****   }
 415:../SPL/src/stm32f10x_usart.c ****   else if (usartreg == 0x02) /* The IT is in CR2 register */
 1126              		.loc 1 415 0
 1127 0726 3B69     		ldr	r3, [r7, #16]
 1128 0728 022B     		cmp	r3, #2
 1129 072a 04D1     		bne	.L55
 416:../SPL/src/stm32f10x_usart.c ****   {
 417:../SPL/src/stm32f10x_usart.c ****     usartxbase += 0x10;
 1130              		.loc 1 417 0
 1131 072c 7B69     		ldr	r3, [r7, #20]
 1132 072e 03F11003 		add	r3, r3, #16
 1133 0732 7B61     		str	r3, [r7, #20]
 1134 0734 03E0     		b	.L54
 1135              	.L55:
 418:../SPL/src/stm32f10x_usart.c ****   }
 419:../SPL/src/stm32f10x_usart.c ****   else /* The IT is in CR3 register */
 420:../SPL/src/stm32f10x_usart.c ****   {
 421:../SPL/src/stm32f10x_usart.c ****     usartxbase += 0x14; 
 1136              		.loc 1 421 0
 1137 0736 7B69     		ldr	r3, [r7, #20]
 1138 0738 03F11403 		add	r3, r3, #20
 1139 073c 7B61     		str	r3, [r7, #20]
 1140              	.L54:
 422:../SPL/src/stm32f10x_usart.c ****   }
 423:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1141              		.loc 1 423 0
 1142 073e 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1143 0740 002B     		cmp	r3, #0
 1144 0742 06D0     		beq	.L56
 424:../SPL/src/stm32f10x_usart.c ****   {
 425:../SPL/src/stm32f10x_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 1145              		.loc 1 425 0
 1146 0744 7B69     		ldr	r3, [r7, #20]
 1147 0746 7A69     		ldr	r2, [r7, #20]
 1148 0748 1168     		ldr	r1, [r2, #0]
 1149 074a BA68     		ldr	r2, [r7, #8]
 1150 074c 0A43     		orrs	r2, r2, r1
 1151 074e 1A60     		str	r2, [r3, #0]
 1152 0750 07E0     		b	.L48
 1153              	.L56:
 426:../SPL/src/stm32f10x_usart.c ****   }
 427:../SPL/src/stm32f10x_usart.c ****   else
 428:../SPL/src/stm32f10x_usart.c ****   {
 429:../SPL/src/stm32f10x_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 1154              		.loc 1 429 0
 1155 0752 7B69     		ldr	r3, [r7, #20]
 1156 0754 7A69     		ldr	r2, [r7, #20]
 1157 0756 1168     		ldr	r1, [r2, #0]
 1158 0758 BA68     		ldr	r2, [r7, #8]
 1159 075a 6FEA0202 		mvn	r2, r2
 1160 075e 0A40     		ands	r2, r2, r1
 1161 0760 1A60     		str	r2, [r3, #0]
 1162              	.L48:
 430:../SPL/src/stm32f10x_usart.c ****   }
 431:../SPL/src/stm32f10x_usart.c **** }
 1163              		.loc 1 431 0
 1164 0762 07F11807 		add	r7, r7, #24
 1165 0766 BD46     		mov	sp, r7
 1166 0768 80BD     		pop	{r7, pc}
 1167              	.L59:
 1168 076a 00BF     		.align	2
 1169              	.L58:
 1170 076c 00380140 		.word	1073821696
 1171 0770 00440040 		.word	1073759232
 1172 0774 00480040 		.word	1073760256
 1173 0778 004C0040 		.word	1073761280
 1174 077c 00500040 		.word	1073762304
 1175 0780 00000000 		.word	.LC0
 1176              		.cfi_endproc
 1177              	.LFE35:
 1179              		.align	2
 1180              		.global	USART_DMACmd
 1181              		.thumb
 1182              		.thumb_func
 1184              	USART_DMACmd:
 1185              	.LFB36:
 432:../SPL/src/stm32f10x_usart.c **** 
 433:../SPL/src/stm32f10x_usart.c **** /**
 434:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs DMA interface.
 435:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 436:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 437:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 438:../SPL/src/stm32f10x_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
 439:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be any combination of the following values:
 440:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_DMAReq_Tx: USART DMA transmit request
 441:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_DMAReq_Rx: USART DMA receive request
 442:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the DMA Request sources.
 443:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 444:../SPL/src/stm32f10x_usart.c ****   * @note The DMA mode is not available for UART5 except in the STM32
 445:../SPL/src/stm32f10x_usart.c ****   *       High density value line devices(STM32F10X_HD_VL).  
 446:../SPL/src/stm32f10x_usart.c ****   * @retval None
 447:../SPL/src/stm32f10x_usart.c ****   */
 448:../SPL/src/stm32f10x_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
 449:../SPL/src/stm32f10x_usart.c **** {
 1186              		.loc 1 449 0
 1187              		.cfi_startproc
 1188              		@ args = 0, pretend = 0, frame = 8
 1189              		@ frame_needed = 1, uses_anonymous_args = 0
 1190 0784 80B5     		push	{r7, lr}
 1191              	.LCFI21:
 1192              		.cfi_def_cfa_offset 8
 1193              		.cfi_offset 7, -8
 1194              		.cfi_offset 14, -4
 1195 0786 82B0     		sub	sp, sp, #8
 1196              	.LCFI22:
 1197              		.cfi_def_cfa_offset 16
 1198 0788 00AF     		add	r7, sp, #0
 1199              	.LCFI23:
 1200              		.cfi_def_cfa_register 7
 1201 078a 7860     		str	r0, [r7, #4]
 1202 078c 1346     		mov	r3, r2
 1203 078e 0A46     		mov	r2, r1	@ movhi
 1204 0790 7A80     		strh	r2, [r7, #2]	@ movhi
 1205 0792 7B70     		strb	r3, [r7, #1]
 450:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 451:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1206              		.loc 1 451 0
 1207 0794 7A68     		ldr	r2, [r7, #4]
 1208 0796 264B     		ldr	r3, .L67
 1209 0798 9A42     		cmp	r2, r3
 1210 079a 14D0     		beq	.L61
 1211              		.loc 1 451 0 is_stmt 0 discriminator 1
 1212 079c 7A68     		ldr	r2, [r7, #4]
 1213 079e 254B     		ldr	r3, .L67+4
 1214 07a0 9A42     		cmp	r2, r3
 1215 07a2 10D0     		beq	.L61
 1216              		.loc 1 451 0 discriminator 2
 1217 07a4 7A68     		ldr	r2, [r7, #4]
 1218 07a6 244B     		ldr	r3, .L67+8
 1219 07a8 9A42     		cmp	r2, r3
 1220 07aa 0CD0     		beq	.L61
 1221              		.loc 1 451 0 discriminator 3
 1222 07ac 7A68     		ldr	r2, [r7, #4]
 1223 07ae 234B     		ldr	r3, .L67+12
 1224 07b0 9A42     		cmp	r2, r3
 1225 07b2 08D0     		beq	.L61
 1226              		.loc 1 451 0 discriminator 4
 1227 07b4 7A68     		ldr	r2, [r7, #4]
 1228 07b6 224B     		ldr	r3, .L67+16
 1229 07b8 9A42     		cmp	r2, r3
 1230 07ba 04D0     		beq	.L61
 1231              		.loc 1 451 0 discriminator 5
 1232 07bc 2148     		ldr	r0, .L67+20
 1233 07be 40F2C311 		movw	r1, #451
 1234 07c2 FFF7FEFF 		bl	assert_failed
 1235              	.L61:
 452:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
 1236              		.loc 1 452 0 is_stmt 1
 1237 07c6 7A88     		ldrh	r2, [r7, #2]
 1238 07c8 4FF63F73 		movw	r3, #65343
 1239 07cc 1340     		ands	r3, r3, r2
 1240 07ce 002B     		cmp	r3, #0
 1241 07d0 02D1     		bne	.L62
 1242              		.loc 1 452 0 is_stmt 0 discriminator 2
 1243 07d2 7B88     		ldrh	r3, [r7, #2]
 1244 07d4 002B     		cmp	r3, #0
 1245 07d6 04D1     		bne	.L63
 1246              	.L62:
 1247              		.loc 1 452 0 discriminator 1
 1248 07d8 1A48     		ldr	r0, .L67+20
 1249 07da 4FF4E271 		mov	r1, #452
 1250 07de FFF7FEFF 		bl	assert_failed
 1251              	.L63:
 453:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 1252              		.loc 1 453 0 is_stmt 1
 1253 07e2 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1254 07e4 002B     		cmp	r3, #0
 1255 07e6 07D0     		beq	.L64
 1256              		.loc 1 453 0 is_stmt 0 discriminator 1
 1257 07e8 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1258 07ea 012B     		cmp	r3, #1
 1259 07ec 04D0     		beq	.L64
 1260              		.loc 1 453 0 discriminator 2
 1261 07ee 1548     		ldr	r0, .L67+20
 1262 07f0 40F2C511 		movw	r1, #453
 1263 07f4 FFF7FEFF 		bl	assert_failed
 1264              	.L64:
 454:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1265              		.loc 1 454 0 is_stmt 1
 1266 07f8 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1267 07fa 002B     		cmp	r3, #0
 1268 07fc 08D0     		beq	.L65
 455:../SPL/src/stm32f10x_usart.c ****   {
 456:../SPL/src/stm32f10x_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
 457:../SPL/src/stm32f10x_usart.c ****        DMAR bits in the USART CR3 register */
 458:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 1269              		.loc 1 458 0
 1270 07fe 7B68     		ldr	r3, [r7, #4]
 1271 0800 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1272 0802 9AB2     		uxth	r2, r3
 1273 0804 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1274 0806 1343     		orrs	r3, r3, r2
 1275 0808 9AB2     		uxth	r2, r3
 1276 080a 7B68     		ldr	r3, [r7, #4]
 1277 080c 9A82     		strh	r2, [r3, #20]	@ movhi
 1278 080e 0AE0     		b	.L60
 1279              	.L65:
 459:../SPL/src/stm32f10x_usart.c ****   }
 460:../SPL/src/stm32f10x_usart.c ****   else
 461:../SPL/src/stm32f10x_usart.c ****   {
 462:../SPL/src/stm32f10x_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
 463:../SPL/src/stm32f10x_usart.c ****        DMAR bits in the USART CR3 register */
 464:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 1280              		.loc 1 464 0
 1281 0810 7B68     		ldr	r3, [r7, #4]
 1282 0812 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1283 0814 9AB2     		uxth	r2, r3
 1284 0816 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1285 0818 6FEA0303 		mvn	r3, r3
 1286 081c 9BB2     		uxth	r3, r3
 1287 081e 1340     		ands	r3, r3, r2
 1288 0820 9AB2     		uxth	r2, r3
 1289 0822 7B68     		ldr	r3, [r7, #4]
 1290 0824 9A82     		strh	r2, [r3, #20]	@ movhi
 1291              	.L60:
 465:../SPL/src/stm32f10x_usart.c ****   }
 466:../SPL/src/stm32f10x_usart.c **** }
 1292              		.loc 1 466 0
 1293 0826 07F10807 		add	r7, r7, #8
 1294 082a BD46     		mov	sp, r7
 1295 082c 80BD     		pop	{r7, pc}
 1296              	.L68:
 1297 082e 00BF     		.align	2
 1298              	.L67:
 1299 0830 00380140 		.word	1073821696
 1300 0834 00440040 		.word	1073759232
 1301 0838 00480040 		.word	1073760256
 1302 083c 004C0040 		.word	1073761280
 1303 0840 00500040 		.word	1073762304
 1304 0844 00000000 		.word	.LC0
 1305              		.cfi_endproc
 1306              	.LFE36:
 1308              		.align	2
 1309              		.global	USART_SetAddress
 1310              		.thumb
 1311              		.thumb_func
 1313              	USART_SetAddress:
 1314              	.LFB37:
 467:../SPL/src/stm32f10x_usart.c **** 
 468:../SPL/src/stm32f10x_usart.c **** /**
 469:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the address of the USART node.
 470:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 471:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 472:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 473:../SPL/src/stm32f10x_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 474:../SPL/src/stm32f10x_usart.c ****   * @retval None
 475:../SPL/src/stm32f10x_usart.c ****   */
 476:../SPL/src/stm32f10x_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 477:../SPL/src/stm32f10x_usart.c **** {
 1315              		.loc 1 477 0
 1316              		.cfi_startproc
 1317              		@ args = 0, pretend = 0, frame = 8
 1318              		@ frame_needed = 1, uses_anonymous_args = 0
 1319 0848 80B5     		push	{r7, lr}
 1320              	.LCFI24:
 1321              		.cfi_def_cfa_offset 8
 1322              		.cfi_offset 7, -8
 1323              		.cfi_offset 14, -4
 1324 084a 82B0     		sub	sp, sp, #8
 1325              	.LCFI25:
 1326              		.cfi_def_cfa_offset 16
 1327 084c 00AF     		add	r7, sp, #0
 1328              	.LCFI26:
 1329              		.cfi_def_cfa_register 7
 1330 084e 7860     		str	r0, [r7, #4]
 1331 0850 0B46     		mov	r3, r1
 1332 0852 FB70     		strb	r3, [r7, #3]
 478:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 479:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1333              		.loc 1 479 0
 1334 0854 7A68     		ldr	r2, [r7, #4]
 1335 0856 1A4B     		ldr	r3, .L72
 1336 0858 9A42     		cmp	r2, r3
 1337 085a 14D0     		beq	.L70
 1338              		.loc 1 479 0 is_stmt 0 discriminator 1
 1339 085c 7A68     		ldr	r2, [r7, #4]
 1340 085e 194B     		ldr	r3, .L72+4
 1341 0860 9A42     		cmp	r2, r3
 1342 0862 10D0     		beq	.L70
 1343              		.loc 1 479 0 discriminator 2
 1344 0864 7A68     		ldr	r2, [r7, #4]
 1345 0866 184B     		ldr	r3, .L72+8
 1346 0868 9A42     		cmp	r2, r3
 1347 086a 0CD0     		beq	.L70
 1348              		.loc 1 479 0 discriminator 3
 1349 086c 7A68     		ldr	r2, [r7, #4]
 1350 086e 174B     		ldr	r3, .L72+12
 1351 0870 9A42     		cmp	r2, r3
 1352 0872 08D0     		beq	.L70
 1353              		.loc 1 479 0 discriminator 4
 1354 0874 7A68     		ldr	r2, [r7, #4]
 1355 0876 164B     		ldr	r3, .L72+16
 1356 0878 9A42     		cmp	r2, r3
 1357 087a 04D0     		beq	.L70
 1358              		.loc 1 479 0 discriminator 5
 1359 087c 1548     		ldr	r0, .L72+20
 1360 087e 40F2DF11 		movw	r1, #479
 1361 0882 FFF7FEFF 		bl	assert_failed
 1362              	.L70:
 480:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ADDRESS(USART_Address)); 
 1363              		.loc 1 480 0 is_stmt 1
 1364 0886 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1365 0888 0F2B     		cmp	r3, #15
 1366 088a 04D9     		bls	.L71
 1367              		.loc 1 480 0 is_stmt 0 discriminator 1
 1368 088c 1148     		ldr	r0, .L72+20
 1369 088e 4FF4F071 		mov	r1, #480
 1370 0892 FFF7FEFF 		bl	assert_failed
 1371              	.L71:
 481:../SPL/src/stm32f10x_usart.c ****     
 482:../SPL/src/stm32f10x_usart.c ****   /* Clear the USART address */
 483:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 &= CR2_Address_Mask;
 1372              		.loc 1 483 0 is_stmt 1
 1373 0896 7B68     		ldr	r3, [r7, #4]
 1374 0898 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1375 089a 9BB2     		uxth	r3, r3
 1376 089c 23F00F03 		bic	r3, r3, #15
 1377 08a0 9AB2     		uxth	r2, r3
 1378 08a2 7B68     		ldr	r3, [r7, #4]
 1379 08a4 1A82     		strh	r2, [r3, #16]	@ movhi
 484:../SPL/src/stm32f10x_usart.c ****   /* Set the USART address node */
 485:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 |= USART_Address;
 1380              		.loc 1 485 0
 1381 08a6 7B68     		ldr	r3, [r7, #4]
 1382 08a8 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1383 08aa 9AB2     		uxth	r2, r3
 1384 08ac FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1385 08ae 9BB2     		uxth	r3, r3
 1386 08b0 1343     		orrs	r3, r3, r2
 1387 08b2 9AB2     		uxth	r2, r3
 1388 08b4 7B68     		ldr	r3, [r7, #4]
 1389 08b6 1A82     		strh	r2, [r3, #16]	@ movhi
 486:../SPL/src/stm32f10x_usart.c **** }
 1390              		.loc 1 486 0
 1391 08b8 07F10807 		add	r7, r7, #8
 1392 08bc BD46     		mov	sp, r7
 1393 08be 80BD     		pop	{r7, pc}
 1394              	.L73:
 1395              		.align	2
 1396              	.L72:
 1397 08c0 00380140 		.word	1073821696
 1398 08c4 00440040 		.word	1073759232
 1399 08c8 00480040 		.word	1073760256
 1400 08cc 004C0040 		.word	1073761280
 1401 08d0 00500040 		.word	1073762304
 1402 08d4 00000000 		.word	.LC0
 1403              		.cfi_endproc
 1404              	.LFE37:
 1406              		.align	2
 1407              		.global	USART_WakeUpConfig
 1408              		.thumb
 1409              		.thumb_func
 1411              	USART_WakeUpConfig:
 1412              	.LFB38:
 487:../SPL/src/stm32f10x_usart.c **** 
 488:../SPL/src/stm32f10x_usart.c **** /**
 489:../SPL/src/stm32f10x_usart.c ****   * @brief  Selects the USART WakeUp method.
 490:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 491:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 492:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 493:../SPL/src/stm32f10x_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
 494:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 495:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
 496:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
 497:../SPL/src/stm32f10x_usart.c ****   * @retval None
 498:../SPL/src/stm32f10x_usart.c ****   */
 499:../SPL/src/stm32f10x_usart.c **** void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
 500:../SPL/src/stm32f10x_usart.c **** {
 1413              		.loc 1 500 0
 1414              		.cfi_startproc
 1415              		@ args = 0, pretend = 0, frame = 8
 1416              		@ frame_needed = 1, uses_anonymous_args = 0
 1417 08d8 80B5     		push	{r7, lr}
 1418              	.LCFI27:
 1419              		.cfi_def_cfa_offset 8
 1420              		.cfi_offset 7, -8
 1421              		.cfi_offset 14, -4
 1422 08da 82B0     		sub	sp, sp, #8
 1423              	.LCFI28:
 1424              		.cfi_def_cfa_offset 16
 1425 08dc 00AF     		add	r7, sp, #0
 1426              	.LCFI29:
 1427              		.cfi_def_cfa_register 7
 1428 08de 7860     		str	r0, [r7, #4]
 1429 08e0 0B46     		mov	r3, r1
 1430 08e2 7B80     		strh	r3, [r7, #2]	@ movhi
 501:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 502:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1431              		.loc 1 502 0
 1432 08e4 7A68     		ldr	r2, [r7, #4]
 1433 08e6 1C4B     		ldr	r3, .L77
 1434 08e8 9A42     		cmp	r2, r3
 1435 08ea 14D0     		beq	.L75
 1436              		.loc 1 502 0 is_stmt 0 discriminator 1
 1437 08ec 7A68     		ldr	r2, [r7, #4]
 1438 08ee 1B4B     		ldr	r3, .L77+4
 1439 08f0 9A42     		cmp	r2, r3
 1440 08f2 10D0     		beq	.L75
 1441              		.loc 1 502 0 discriminator 2
 1442 08f4 7A68     		ldr	r2, [r7, #4]
 1443 08f6 1A4B     		ldr	r3, .L77+8
 1444 08f8 9A42     		cmp	r2, r3
 1445 08fa 0CD0     		beq	.L75
 1446              		.loc 1 502 0 discriminator 3
 1447 08fc 7A68     		ldr	r2, [r7, #4]
 1448 08fe 194B     		ldr	r3, .L77+12
 1449 0900 9A42     		cmp	r2, r3
 1450 0902 08D0     		beq	.L75
 1451              		.loc 1 502 0 discriminator 4
 1452 0904 7A68     		ldr	r2, [r7, #4]
 1453 0906 184B     		ldr	r3, .L77+16
 1454 0908 9A42     		cmp	r2, r3
 1455 090a 04D0     		beq	.L75
 1456              		.loc 1 502 0 discriminator 5
 1457 090c 1748     		ldr	r0, .L77+20
 1458 090e 4FF4FB71 		mov	r1, #502
 1459 0912 FFF7FEFF 		bl	assert_failed
 1460              	.L75:
 503:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_WAKEUP(USART_WakeUp));
 1461              		.loc 1 503 0 is_stmt 1
 1462 0916 7B88     		ldrh	r3, [r7, #2]
 1463 0918 002B     		cmp	r3, #0
 1464 091a 08D0     		beq	.L76
 1465              		.loc 1 503 0 is_stmt 0 discriminator 1
 1466 091c 7B88     		ldrh	r3, [r7, #2]
 1467 091e B3F5006F 		cmp	r3, #2048
 1468 0922 04D0     		beq	.L76
 1469              		.loc 1 503 0 discriminator 2
 1470 0924 1148     		ldr	r0, .L77+20
 1471 0926 40F2F711 		movw	r1, #503
 1472 092a FFF7FEFF 		bl	assert_failed
 1473              	.L76:
 504:../SPL/src/stm32f10x_usart.c ****   
 505:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 &= CR1_WAKE_Mask;
 1474              		.loc 1 505 0 is_stmt 1
 1475 092e 7B68     		ldr	r3, [r7, #4]
 1476 0930 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1477 0932 9BB2     		uxth	r3, r3
 1478 0934 23F40063 		bic	r3, r3, #2048
 1479 0938 9AB2     		uxth	r2, r3
 1480 093a 7B68     		ldr	r3, [r7, #4]
 1481 093c 9A81     		strh	r2, [r3, #12]	@ movhi
 506:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 1482              		.loc 1 506 0
 1483 093e 7B68     		ldr	r3, [r7, #4]
 1484 0940 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1485 0942 9AB2     		uxth	r2, r3
 1486 0944 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1487 0946 1343     		orrs	r3, r3, r2
 1488 0948 9AB2     		uxth	r2, r3
 1489 094a 7B68     		ldr	r3, [r7, #4]
 1490 094c 9A81     		strh	r2, [r3, #12]	@ movhi
 507:../SPL/src/stm32f10x_usart.c **** }
 1491              		.loc 1 507 0
 1492 094e 07F10807 		add	r7, r7, #8
 1493 0952 BD46     		mov	sp, r7
 1494 0954 80BD     		pop	{r7, pc}
 1495              	.L78:
 1496 0956 00BF     		.align	2
 1497              	.L77:
 1498 0958 00380140 		.word	1073821696
 1499 095c 00440040 		.word	1073759232
 1500 0960 00480040 		.word	1073760256
 1501 0964 004C0040 		.word	1073761280
 1502 0968 00500040 		.word	1073762304
 1503 096c 00000000 		.word	.LC0
 1504              		.cfi_endproc
 1505              	.LFE38:
 1507              		.align	2
 1508              		.global	USART_ReceiverWakeUpCmd
 1509              		.thumb
 1510              		.thumb_func
 1512              	USART_ReceiverWakeUpCmd:
 1513              	.LFB39:
 508:../SPL/src/stm32f10x_usart.c **** 
 509:../SPL/src/stm32f10x_usart.c **** /**
 510:../SPL/src/stm32f10x_usart.c ****   * @brief  Determines if the USART is in mute mode or not.
 511:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 512:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 513:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 514:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART mute mode.
 515:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 516:../SPL/src/stm32f10x_usart.c ****   * @retval None
 517:../SPL/src/stm32f10x_usart.c ****   */
 518:../SPL/src/stm32f10x_usart.c **** void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 519:../SPL/src/stm32f10x_usart.c **** {
 1514              		.loc 1 519 0
 1515              		.cfi_startproc
 1516              		@ args = 0, pretend = 0, frame = 8
 1517              		@ frame_needed = 1, uses_anonymous_args = 0
 1518 0970 80B5     		push	{r7, lr}
 1519              	.LCFI30:
 1520              		.cfi_def_cfa_offset 8
 1521              		.cfi_offset 7, -8
 1522              		.cfi_offset 14, -4
 1523 0972 82B0     		sub	sp, sp, #8
 1524              	.LCFI31:
 1525              		.cfi_def_cfa_offset 16
 1526 0974 00AF     		add	r7, sp, #0
 1527              	.LCFI32:
 1528              		.cfi_def_cfa_register 7
 1529 0976 7860     		str	r0, [r7, #4]
 1530 0978 0B46     		mov	r3, r1
 1531 097a FB70     		strb	r3, [r7, #3]
 520:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 521:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1532              		.loc 1 521 0
 1533 097c 7A68     		ldr	r2, [r7, #4]
 1534 097e 1D4B     		ldr	r3, .L84
 1535 0980 9A42     		cmp	r2, r3
 1536 0982 14D0     		beq	.L80
 1537              		.loc 1 521 0 is_stmt 0 discriminator 1
 1538 0984 7A68     		ldr	r2, [r7, #4]
 1539 0986 1C4B     		ldr	r3, .L84+4
 1540 0988 9A42     		cmp	r2, r3
 1541 098a 10D0     		beq	.L80
 1542              		.loc 1 521 0 discriminator 2
 1543 098c 7A68     		ldr	r2, [r7, #4]
 1544 098e 1B4B     		ldr	r3, .L84+8
 1545 0990 9A42     		cmp	r2, r3
 1546 0992 0CD0     		beq	.L80
 1547              		.loc 1 521 0 discriminator 3
 1548 0994 7A68     		ldr	r2, [r7, #4]
 1549 0996 1A4B     		ldr	r3, .L84+12
 1550 0998 9A42     		cmp	r2, r3
 1551 099a 08D0     		beq	.L80
 1552              		.loc 1 521 0 discriminator 4
 1553 099c 7A68     		ldr	r2, [r7, #4]
 1554 099e 194B     		ldr	r3, .L84+16
 1555 09a0 9A42     		cmp	r2, r3
 1556 09a2 04D0     		beq	.L80
 1557              		.loc 1 521 0 discriminator 5
 1558 09a4 1848     		ldr	r0, .L84+20
 1559 09a6 40F20921 		movw	r1, #521
 1560 09aa FFF7FEFF 		bl	assert_failed
 1561              	.L80:
 522:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 1562              		.loc 1 522 0 is_stmt 1
 1563 09ae FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1564 09b0 002B     		cmp	r3, #0
 1565 09b2 07D0     		beq	.L81
 1566              		.loc 1 522 0 is_stmt 0 discriminator 1
 1567 09b4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1568 09b6 012B     		cmp	r3, #1
 1569 09b8 04D0     		beq	.L81
 1570              		.loc 1 522 0 discriminator 2
 1571 09ba 1348     		ldr	r0, .L84+20
 1572 09bc 40F20A21 		movw	r1, #522
 1573 09c0 FFF7FEFF 		bl	assert_failed
 1574              	.L81:
 523:../SPL/src/stm32f10x_usart.c ****   
 524:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1575              		.loc 1 524 0 is_stmt 1
 1576 09c4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1577 09c6 002B     		cmp	r3, #0
 1578 09c8 08D0     		beq	.L82
 525:../SPL/src/stm32f10x_usart.c ****   {
 526:../SPL/src/stm32f10x_usart.c ****     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
 527:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_RWU_Set;
 1579              		.loc 1 527 0
 1580 09ca 7B68     		ldr	r3, [r7, #4]
 1581 09cc 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1582 09ce 9BB2     		uxth	r3, r3
 1583 09d0 43F00203 		orr	r3, r3, #2
 1584 09d4 9AB2     		uxth	r2, r3
 1585 09d6 7B68     		ldr	r3, [r7, #4]
 1586 09d8 9A81     		strh	r2, [r3, #12]	@ movhi
 1587 09da 07E0     		b	.L79
 1588              	.L82:
 528:../SPL/src/stm32f10x_usart.c ****   }
 529:../SPL/src/stm32f10x_usart.c ****   else
 530:../SPL/src/stm32f10x_usart.c ****   {
 531:../SPL/src/stm32f10x_usart.c ****     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
 532:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_RWU_Reset;
 1589              		.loc 1 532 0
 1590 09dc 7B68     		ldr	r3, [r7, #4]
 1591 09de 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1592 09e0 9BB2     		uxth	r3, r3
 1593 09e2 23F00203 		bic	r3, r3, #2
 1594 09e6 9AB2     		uxth	r2, r3
 1595 09e8 7B68     		ldr	r3, [r7, #4]
 1596 09ea 9A81     		strh	r2, [r3, #12]	@ movhi
 1597              	.L79:
 533:../SPL/src/stm32f10x_usart.c ****   }
 534:../SPL/src/stm32f10x_usart.c **** }
 1598              		.loc 1 534 0
 1599 09ec 07F10807 		add	r7, r7, #8
 1600 09f0 BD46     		mov	sp, r7
 1601 09f2 80BD     		pop	{r7, pc}
 1602              	.L85:
 1603              		.align	2
 1604              	.L84:
 1605 09f4 00380140 		.word	1073821696
 1606 09f8 00440040 		.word	1073759232
 1607 09fc 00480040 		.word	1073760256
 1608 0a00 004C0040 		.word	1073761280
 1609 0a04 00500040 		.word	1073762304
 1610 0a08 00000000 		.word	.LC0
 1611              		.cfi_endproc
 1612              	.LFE39:
 1614              		.align	2
 1615              		.global	USART_LINBreakDetectLengthConfig
 1616              		.thumb
 1617              		.thumb_func
 1619              	USART_LINBreakDetectLengthConfig:
 1620              	.LFB40:
 535:../SPL/src/stm32f10x_usart.c **** 
 536:../SPL/src/stm32f10x_usart.c **** /**
 537:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the USART LIN Break detection length.
 538:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 539:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 540:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 541:../SPL/src/stm32f10x_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
 542:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 543:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
 544:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
 545:../SPL/src/stm32f10x_usart.c ****   * @retval None
 546:../SPL/src/stm32f10x_usart.c ****   */
 547:../SPL/src/stm32f10x_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
 548:../SPL/src/stm32f10x_usart.c **** {
 1621              		.loc 1 548 0
 1622              		.cfi_startproc
 1623              		@ args = 0, pretend = 0, frame = 8
 1624              		@ frame_needed = 1, uses_anonymous_args = 0
 1625 0a0c 80B5     		push	{r7, lr}
 1626              	.LCFI33:
 1627              		.cfi_def_cfa_offset 8
 1628              		.cfi_offset 7, -8
 1629              		.cfi_offset 14, -4
 1630 0a0e 82B0     		sub	sp, sp, #8
 1631              	.LCFI34:
 1632              		.cfi_def_cfa_offset 16
 1633 0a10 00AF     		add	r7, sp, #0
 1634              	.LCFI35:
 1635              		.cfi_def_cfa_register 7
 1636 0a12 7860     		str	r0, [r7, #4]
 1637 0a14 0B46     		mov	r3, r1
 1638 0a16 7B80     		strh	r3, [r7, #2]	@ movhi
 549:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 550:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1639              		.loc 1 550 0
 1640 0a18 7A68     		ldr	r2, [r7, #4]
 1641 0a1a 1B4B     		ldr	r3, .L89
 1642 0a1c 9A42     		cmp	r2, r3
 1643 0a1e 14D0     		beq	.L87
 1644              		.loc 1 550 0 is_stmt 0 discriminator 1
 1645 0a20 7A68     		ldr	r2, [r7, #4]
 1646 0a22 1A4B     		ldr	r3, .L89+4
 1647 0a24 9A42     		cmp	r2, r3
 1648 0a26 10D0     		beq	.L87
 1649              		.loc 1 550 0 discriminator 2
 1650 0a28 7A68     		ldr	r2, [r7, #4]
 1651 0a2a 194B     		ldr	r3, .L89+8
 1652 0a2c 9A42     		cmp	r2, r3
 1653 0a2e 0CD0     		beq	.L87
 1654              		.loc 1 550 0 discriminator 3
 1655 0a30 7A68     		ldr	r2, [r7, #4]
 1656 0a32 184B     		ldr	r3, .L89+12
 1657 0a34 9A42     		cmp	r2, r3
 1658 0a36 08D0     		beq	.L87
 1659              		.loc 1 550 0 discriminator 4
 1660 0a38 7A68     		ldr	r2, [r7, #4]
 1661 0a3a 174B     		ldr	r3, .L89+16
 1662 0a3c 9A42     		cmp	r2, r3
 1663 0a3e 04D0     		beq	.L87
 1664              		.loc 1 550 0 discriminator 5
 1665 0a40 1648     		ldr	r0, .L89+20
 1666 0a42 40F22621 		movw	r1, #550
 1667 0a46 FFF7FEFF 		bl	assert_failed
 1668              	.L87:
 551:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
 1669              		.loc 1 551 0 is_stmt 1
 1670 0a4a 7B88     		ldrh	r3, [r7, #2]
 1671 0a4c 002B     		cmp	r3, #0
 1672 0a4e 07D0     		beq	.L88
 1673              		.loc 1 551 0 is_stmt 0 discriminator 1
 1674 0a50 7B88     		ldrh	r3, [r7, #2]
 1675 0a52 202B     		cmp	r3, #32
 1676 0a54 04D0     		beq	.L88
 1677              		.loc 1 551 0 discriminator 2
 1678 0a56 1148     		ldr	r0, .L89+20
 1679 0a58 40F22721 		movw	r1, #551
 1680 0a5c FFF7FEFF 		bl	assert_failed
 1681              	.L88:
 552:../SPL/src/stm32f10x_usart.c ****   
 553:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 &= CR2_LBDL_Mask;
 1682              		.loc 1 553 0 is_stmt 1
 1683 0a60 7B68     		ldr	r3, [r7, #4]
 1684 0a62 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1685 0a64 9BB2     		uxth	r3, r3
 1686 0a66 23F02003 		bic	r3, r3, #32
 1687 0a6a 9AB2     		uxth	r2, r3
 1688 0a6c 7B68     		ldr	r3, [r7, #4]
 1689 0a6e 1A82     		strh	r2, [r3, #16]	@ movhi
 554:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 1690              		.loc 1 554 0
 1691 0a70 7B68     		ldr	r3, [r7, #4]
 1692 0a72 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1693 0a74 9AB2     		uxth	r2, r3
 1694 0a76 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1695 0a78 1343     		orrs	r3, r3, r2
 1696 0a7a 9AB2     		uxth	r2, r3
 1697 0a7c 7B68     		ldr	r3, [r7, #4]
 1698 0a7e 1A82     		strh	r2, [r3, #16]	@ movhi
 555:../SPL/src/stm32f10x_usart.c **** }
 1699              		.loc 1 555 0
 1700 0a80 07F10807 		add	r7, r7, #8
 1701 0a84 BD46     		mov	sp, r7
 1702 0a86 80BD     		pop	{r7, pc}
 1703              	.L90:
 1704              		.align	2
 1705              	.L89:
 1706 0a88 00380140 		.word	1073821696
 1707 0a8c 00440040 		.word	1073759232
 1708 0a90 00480040 		.word	1073760256
 1709 0a94 004C0040 		.word	1073761280
 1710 0a98 00500040 		.word	1073762304
 1711 0a9c 00000000 		.word	.LC0
 1712              		.cfi_endproc
 1713              	.LFE40:
 1715              		.align	2
 1716              		.global	USART_LINCmd
 1717              		.thumb
 1718              		.thumb_func
 1720              	USART_LINCmd:
 1721              	.LFB41:
 556:../SPL/src/stm32f10x_usart.c **** 
 557:../SPL/src/stm32f10x_usart.c **** /**
 558:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs LIN mode.
 559:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 560:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 561:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 562:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART LIN mode.
 563:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 564:../SPL/src/stm32f10x_usart.c ****   * @retval None
 565:../SPL/src/stm32f10x_usart.c ****   */
 566:../SPL/src/stm32f10x_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 567:../SPL/src/stm32f10x_usart.c **** {
 1722              		.loc 1 567 0
 1723              		.cfi_startproc
 1724              		@ args = 0, pretend = 0, frame = 8
 1725              		@ frame_needed = 1, uses_anonymous_args = 0
 1726 0aa0 80B5     		push	{r7, lr}
 1727              	.LCFI36:
 1728              		.cfi_def_cfa_offset 8
 1729              		.cfi_offset 7, -8
 1730              		.cfi_offset 14, -4
 1731 0aa2 82B0     		sub	sp, sp, #8
 1732              	.LCFI37:
 1733              		.cfi_def_cfa_offset 16
 1734 0aa4 00AF     		add	r7, sp, #0
 1735              	.LCFI38:
 1736              		.cfi_def_cfa_register 7
 1737 0aa6 7860     		str	r0, [r7, #4]
 1738 0aa8 0B46     		mov	r3, r1
 1739 0aaa FB70     		strb	r3, [r7, #3]
 568:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 569:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1740              		.loc 1 569 0
 1741 0aac 7A68     		ldr	r2, [r7, #4]
 1742 0aae 1D4B     		ldr	r3, .L96
 1743 0ab0 9A42     		cmp	r2, r3
 1744 0ab2 14D0     		beq	.L92
 1745              		.loc 1 569 0 is_stmt 0 discriminator 1
 1746 0ab4 7A68     		ldr	r2, [r7, #4]
 1747 0ab6 1C4B     		ldr	r3, .L96+4
 1748 0ab8 9A42     		cmp	r2, r3
 1749 0aba 10D0     		beq	.L92
 1750              		.loc 1 569 0 discriminator 2
 1751 0abc 7A68     		ldr	r2, [r7, #4]
 1752 0abe 1B4B     		ldr	r3, .L96+8
 1753 0ac0 9A42     		cmp	r2, r3
 1754 0ac2 0CD0     		beq	.L92
 1755              		.loc 1 569 0 discriminator 3
 1756 0ac4 7A68     		ldr	r2, [r7, #4]
 1757 0ac6 1A4B     		ldr	r3, .L96+12
 1758 0ac8 9A42     		cmp	r2, r3
 1759 0aca 08D0     		beq	.L92
 1760              		.loc 1 569 0 discriminator 4
 1761 0acc 7A68     		ldr	r2, [r7, #4]
 1762 0ace 194B     		ldr	r3, .L96+16
 1763 0ad0 9A42     		cmp	r2, r3
 1764 0ad2 04D0     		beq	.L92
 1765              		.loc 1 569 0 discriminator 5
 1766 0ad4 1848     		ldr	r0, .L96+20
 1767 0ad6 40F23921 		movw	r1, #569
 1768 0ada FFF7FEFF 		bl	assert_failed
 1769              	.L92:
 570:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 1770              		.loc 1 570 0 is_stmt 1
 1771 0ade FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1772 0ae0 002B     		cmp	r3, #0
 1773 0ae2 07D0     		beq	.L93
 1774              		.loc 1 570 0 is_stmt 0 discriminator 1
 1775 0ae4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1776 0ae6 012B     		cmp	r3, #1
 1777 0ae8 04D0     		beq	.L93
 1778              		.loc 1 570 0 discriminator 2
 1779 0aea 1348     		ldr	r0, .L96+20
 1780 0aec 40F23A21 		movw	r1, #570
 1781 0af0 FFF7FEFF 		bl	assert_failed
 1782              	.L93:
 571:../SPL/src/stm32f10x_usart.c ****   
 572:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1783              		.loc 1 572 0 is_stmt 1
 1784 0af4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1785 0af6 002B     		cmp	r3, #0
 1786 0af8 08D0     		beq	.L94
 573:../SPL/src/stm32f10x_usart.c ****   {
 574:../SPL/src/stm32f10x_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 575:../SPL/src/stm32f10x_usart.c ****     USARTx->CR2 |= CR2_LINEN_Set;
 1787              		.loc 1 575 0
 1788 0afa 7B68     		ldr	r3, [r7, #4]
 1789 0afc 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1790 0afe 9BB2     		uxth	r3, r3
 1791 0b00 43F48043 		orr	r3, r3, #16384
 1792 0b04 9AB2     		uxth	r2, r3
 1793 0b06 7B68     		ldr	r3, [r7, #4]
 1794 0b08 1A82     		strh	r2, [r3, #16]	@ movhi
 1795 0b0a 07E0     		b	.L91
 1796              	.L94:
 576:../SPL/src/stm32f10x_usart.c ****   }
 577:../SPL/src/stm32f10x_usart.c ****   else
 578:../SPL/src/stm32f10x_usart.c ****   {
 579:../SPL/src/stm32f10x_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
 580:../SPL/src/stm32f10x_usart.c ****     USARTx->CR2 &= CR2_LINEN_Reset;
 1797              		.loc 1 580 0
 1798 0b0c 7B68     		ldr	r3, [r7, #4]
 1799 0b0e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1800 0b10 9BB2     		uxth	r3, r3
 1801 0b12 23F48043 		bic	r3, r3, #16384
 1802 0b16 9AB2     		uxth	r2, r3
 1803 0b18 7B68     		ldr	r3, [r7, #4]
 1804 0b1a 1A82     		strh	r2, [r3, #16]	@ movhi
 1805              	.L91:
 581:../SPL/src/stm32f10x_usart.c ****   }
 582:../SPL/src/stm32f10x_usart.c **** }
 1806              		.loc 1 582 0
 1807 0b1c 07F10807 		add	r7, r7, #8
 1808 0b20 BD46     		mov	sp, r7
 1809 0b22 80BD     		pop	{r7, pc}
 1810              	.L97:
 1811              		.align	2
 1812              	.L96:
 1813 0b24 00380140 		.word	1073821696
 1814 0b28 00440040 		.word	1073759232
 1815 0b2c 00480040 		.word	1073760256
 1816 0b30 004C0040 		.word	1073761280
 1817 0b34 00500040 		.word	1073762304
 1818 0b38 00000000 		.word	.LC0
 1819              		.cfi_endproc
 1820              	.LFE41:
 1822              		.align	2
 1823              		.global	USART_SendData
 1824              		.thumb
 1825              		.thumb_func
 1827              	USART_SendData:
 1828              	.LFB42:
 583:../SPL/src/stm32f10x_usart.c **** 
 584:../SPL/src/stm32f10x_usart.c **** /**
 585:../SPL/src/stm32f10x_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 586:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 587:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 588:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 589:../SPL/src/stm32f10x_usart.c ****   * @param  Data: the data to transmit.
 590:../SPL/src/stm32f10x_usart.c ****   * @retval None
 591:../SPL/src/stm32f10x_usart.c ****   */
 592:../SPL/src/stm32f10x_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 593:../SPL/src/stm32f10x_usart.c **** {
 1829              		.loc 1 593 0
 1830              		.cfi_startproc
 1831              		@ args = 0, pretend = 0, frame = 8
 1832              		@ frame_needed = 1, uses_anonymous_args = 0
 1833 0b3c 80B5     		push	{r7, lr}
 1834              	.LCFI39:
 1835              		.cfi_def_cfa_offset 8
 1836              		.cfi_offset 7, -8
 1837              		.cfi_offset 14, -4
 1838 0b3e 82B0     		sub	sp, sp, #8
 1839              	.LCFI40:
 1840              		.cfi_def_cfa_offset 16
 1841 0b40 00AF     		add	r7, sp, #0
 1842              	.LCFI41:
 1843              		.cfi_def_cfa_register 7
 1844 0b42 7860     		str	r0, [r7, #4]
 1845 0b44 0B46     		mov	r3, r1
 1846 0b46 7B80     		strh	r3, [r7, #2]	@ movhi
 594:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 595:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1847              		.loc 1 595 0
 1848 0b48 7A68     		ldr	r2, [r7, #4]
 1849 0b4a 174B     		ldr	r3, .L101
 1850 0b4c 9A42     		cmp	r2, r3
 1851 0b4e 14D0     		beq	.L99
 1852              		.loc 1 595 0 is_stmt 0 discriminator 1
 1853 0b50 7A68     		ldr	r2, [r7, #4]
 1854 0b52 164B     		ldr	r3, .L101+4
 1855 0b54 9A42     		cmp	r2, r3
 1856 0b56 10D0     		beq	.L99
 1857              		.loc 1 595 0 discriminator 2
 1858 0b58 7A68     		ldr	r2, [r7, #4]
 1859 0b5a 154B     		ldr	r3, .L101+8
 1860 0b5c 9A42     		cmp	r2, r3
 1861 0b5e 0CD0     		beq	.L99
 1862              		.loc 1 595 0 discriminator 3
 1863 0b60 7A68     		ldr	r2, [r7, #4]
 1864 0b62 144B     		ldr	r3, .L101+12
 1865 0b64 9A42     		cmp	r2, r3
 1866 0b66 08D0     		beq	.L99
 1867              		.loc 1 595 0 discriminator 4
 1868 0b68 7A68     		ldr	r2, [r7, #4]
 1869 0b6a 134B     		ldr	r3, .L101+16
 1870 0b6c 9A42     		cmp	r2, r3
 1871 0b6e 04D0     		beq	.L99
 1872              		.loc 1 595 0 discriminator 5
 1873 0b70 1248     		ldr	r0, .L101+20
 1874 0b72 40F25321 		movw	r1, #595
 1875 0b76 FFF7FEFF 		bl	assert_failed
 1876              	.L99:
 596:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 1877              		.loc 1 596 0 is_stmt 1
 1878 0b7a 7A88     		ldrh	r2, [r7, #2]
 1879 0b7c 40F2FF13 		movw	r3, #511
 1880 0b80 9A42     		cmp	r2, r3
 1881 0b82 04D9     		bls	.L100
 1882              		.loc 1 596 0 is_stmt 0 discriminator 1
 1883 0b84 0D48     		ldr	r0, .L101+20
 1884 0b86 4FF41571 		mov	r1, #596
 1885 0b8a FFF7FEFF 		bl	assert_failed
 1886              	.L100:
 597:../SPL/src/stm32f10x_usart.c ****     
 598:../SPL/src/stm32f10x_usart.c ****   /* Transmit Data */
 599:../SPL/src/stm32f10x_usart.c ****   USARTx->DR = (Data & (uint16_t)0x01FF);
 1887              		.loc 1 599 0 is_stmt 1
 1888 0b8e 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1889 0b90 4FEAC353 		lsl	r3, r3, #23
 1890 0b94 4FEAD353 		lsr	r3, r3, #23
 1891 0b98 9AB2     		uxth	r2, r3
 1892 0b9a 7B68     		ldr	r3, [r7, #4]
 1893 0b9c 9A80     		strh	r2, [r3, #4]	@ movhi
 600:../SPL/src/stm32f10x_usart.c **** }
 1894              		.loc 1 600 0
 1895 0b9e 07F10807 		add	r7, r7, #8
 1896 0ba2 BD46     		mov	sp, r7
 1897 0ba4 80BD     		pop	{r7, pc}
 1898              	.L102:
 1899 0ba6 00BF     		.align	2
 1900              	.L101:
 1901 0ba8 00380140 		.word	1073821696
 1902 0bac 00440040 		.word	1073759232
 1903 0bb0 00480040 		.word	1073760256
 1904 0bb4 004C0040 		.word	1073761280
 1905 0bb8 00500040 		.word	1073762304
 1906 0bbc 00000000 		.word	.LC0
 1907              		.cfi_endproc
 1908              	.LFE42:
 1910              		.align	2
 1911              		.global	USART_ReceiveData
 1912              		.thumb
 1913              		.thumb_func
 1915              	USART_ReceiveData:
 1916              	.LFB43:
 601:../SPL/src/stm32f10x_usart.c **** 
 602:../SPL/src/stm32f10x_usart.c **** /**
 603:../SPL/src/stm32f10x_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 604:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 605:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 606:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 607:../SPL/src/stm32f10x_usart.c ****   * @retval The received data.
 608:../SPL/src/stm32f10x_usart.c ****   */
 609:../SPL/src/stm32f10x_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 610:../SPL/src/stm32f10x_usart.c **** {
 1917              		.loc 1 610 0
 1918              		.cfi_startproc
 1919              		@ args = 0, pretend = 0, frame = 8
 1920              		@ frame_needed = 1, uses_anonymous_args = 0
 1921 0bc0 80B5     		push	{r7, lr}
 1922              	.LCFI42:
 1923              		.cfi_def_cfa_offset 8
 1924              		.cfi_offset 7, -8
 1925              		.cfi_offset 14, -4
 1926 0bc2 82B0     		sub	sp, sp, #8
 1927              	.LCFI43:
 1928              		.cfi_def_cfa_offset 16
 1929 0bc4 00AF     		add	r7, sp, #0
 1930              	.LCFI44:
 1931              		.cfi_def_cfa_register 7
 1932 0bc6 7860     		str	r0, [r7, #4]
 611:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 612:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 1933              		.loc 1 612 0
 1934 0bc8 7A68     		ldr	r2, [r7, #4]
 1935 0bca 124B     		ldr	r3, .L106
 1936 0bcc 9A42     		cmp	r2, r3
 1937 0bce 14D0     		beq	.L104
 1938              		.loc 1 612 0 is_stmt 0 discriminator 1
 1939 0bd0 7A68     		ldr	r2, [r7, #4]
 1940 0bd2 114B     		ldr	r3, .L106+4
 1941 0bd4 9A42     		cmp	r2, r3
 1942 0bd6 10D0     		beq	.L104
 1943              		.loc 1 612 0 discriminator 2
 1944 0bd8 7A68     		ldr	r2, [r7, #4]
 1945 0bda 104B     		ldr	r3, .L106+8
 1946 0bdc 9A42     		cmp	r2, r3
 1947 0bde 0CD0     		beq	.L104
 1948              		.loc 1 612 0 discriminator 3
 1949 0be0 7A68     		ldr	r2, [r7, #4]
 1950 0be2 0F4B     		ldr	r3, .L106+12
 1951 0be4 9A42     		cmp	r2, r3
 1952 0be6 08D0     		beq	.L104
 1953              		.loc 1 612 0 discriminator 4
 1954 0be8 7A68     		ldr	r2, [r7, #4]
 1955 0bea 0E4B     		ldr	r3, .L106+16
 1956 0bec 9A42     		cmp	r2, r3
 1957 0bee 04D0     		beq	.L104
 1958              		.loc 1 612 0 discriminator 5
 1959 0bf0 0D48     		ldr	r0, .L106+20
 1960 0bf2 4FF41971 		mov	r1, #612
 1961 0bf6 FFF7FEFF 		bl	assert_failed
 1962              	.L104:
 613:../SPL/src/stm32f10x_usart.c ****   
 614:../SPL/src/stm32f10x_usart.c ****   /* Receive Data */
 615:../SPL/src/stm32f10x_usart.c ****   return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 1963              		.loc 1 615 0 is_stmt 1
 1964 0bfa 7B68     		ldr	r3, [r7, #4]
 1965 0bfc 9B88     		ldrh	r3, [r3, #4]	@ movhi
 1966 0bfe 9BB2     		uxth	r3, r3
 1967 0c00 4FEAC353 		lsl	r3, r3, #23
 1968 0c04 4FEAD353 		lsr	r3, r3, #23
 1969 0c08 9BB2     		uxth	r3, r3
 616:../SPL/src/stm32f10x_usart.c **** }
 1970              		.loc 1 616 0
 1971 0c0a 1846     		mov	r0, r3
 1972 0c0c 07F10807 		add	r7, r7, #8
 1973 0c10 BD46     		mov	sp, r7
 1974 0c12 80BD     		pop	{r7, pc}
 1975              	.L107:
 1976              		.align	2
 1977              	.L106:
 1978 0c14 00380140 		.word	1073821696
 1979 0c18 00440040 		.word	1073759232
 1980 0c1c 00480040 		.word	1073760256
 1981 0c20 004C0040 		.word	1073761280
 1982 0c24 00500040 		.word	1073762304
 1983 0c28 00000000 		.word	.LC0
 1984              		.cfi_endproc
 1985              	.LFE43:
 1987              		.align	2
 1988              		.global	USART_SendBreak
 1989              		.thumb
 1990              		.thumb_func
 1992              	USART_SendBreak:
 1993              	.LFB44:
 617:../SPL/src/stm32f10x_usart.c **** 
 618:../SPL/src/stm32f10x_usart.c **** /**
 619:../SPL/src/stm32f10x_usart.c ****   * @brief  Transmits break characters.
 620:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 621:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 622:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 623:../SPL/src/stm32f10x_usart.c ****   * @retval None
 624:../SPL/src/stm32f10x_usart.c ****   */
 625:../SPL/src/stm32f10x_usart.c **** void USART_SendBreak(USART_TypeDef* USARTx)
 626:../SPL/src/stm32f10x_usart.c **** {
 1994              		.loc 1 626 0
 1995              		.cfi_startproc
 1996              		@ args = 0, pretend = 0, frame = 8
 1997              		@ frame_needed = 1, uses_anonymous_args = 0
 1998 0c2c 80B5     		push	{r7, lr}
 1999              	.LCFI45:
 2000              		.cfi_def_cfa_offset 8
 2001              		.cfi_offset 7, -8
 2002              		.cfi_offset 14, -4
 2003 0c2e 82B0     		sub	sp, sp, #8
 2004              	.LCFI46:
 2005              		.cfi_def_cfa_offset 16
 2006 0c30 00AF     		add	r7, sp, #0
 2007              	.LCFI47:
 2008              		.cfi_def_cfa_register 7
 2009 0c32 7860     		str	r0, [r7, #4]
 627:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 628:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2010              		.loc 1 628 0
 2011 0c34 7A68     		ldr	r2, [r7, #4]
 2012 0c36 124B     		ldr	r3, .L110
 2013 0c38 9A42     		cmp	r2, r3
 2014 0c3a 14D0     		beq	.L109
 2015              		.loc 1 628 0 is_stmt 0 discriminator 1
 2016 0c3c 7A68     		ldr	r2, [r7, #4]
 2017 0c3e 114B     		ldr	r3, .L110+4
 2018 0c40 9A42     		cmp	r2, r3
 2019 0c42 10D0     		beq	.L109
 2020              		.loc 1 628 0 discriminator 2
 2021 0c44 7A68     		ldr	r2, [r7, #4]
 2022 0c46 104B     		ldr	r3, .L110+8
 2023 0c48 9A42     		cmp	r2, r3
 2024 0c4a 0CD0     		beq	.L109
 2025              		.loc 1 628 0 discriminator 3
 2026 0c4c 7A68     		ldr	r2, [r7, #4]
 2027 0c4e 0F4B     		ldr	r3, .L110+12
 2028 0c50 9A42     		cmp	r2, r3
 2029 0c52 08D0     		beq	.L109
 2030              		.loc 1 628 0 discriminator 4
 2031 0c54 7A68     		ldr	r2, [r7, #4]
 2032 0c56 0E4B     		ldr	r3, .L110+16
 2033 0c58 9A42     		cmp	r2, r3
 2034 0c5a 04D0     		beq	.L109
 2035              		.loc 1 628 0 discriminator 5
 2036 0c5c 0D48     		ldr	r0, .L110+20
 2037 0c5e 4FF41D71 		mov	r1, #628
 2038 0c62 FFF7FEFF 		bl	assert_failed
 2039              	.L109:
 629:../SPL/src/stm32f10x_usart.c ****   
 630:../SPL/src/stm32f10x_usart.c ****   /* Send break characters */
 631:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 |= CR1_SBK_Set;
 2040              		.loc 1 631 0 is_stmt 1
 2041 0c66 7B68     		ldr	r3, [r7, #4]
 2042 0c68 9B89     		ldrh	r3, [r3, #12]	@ movhi
 2043 0c6a 9BB2     		uxth	r3, r3
 2044 0c6c 43F00103 		orr	r3, r3, #1
 2045 0c70 9AB2     		uxth	r2, r3
 2046 0c72 7B68     		ldr	r3, [r7, #4]
 2047 0c74 9A81     		strh	r2, [r3, #12]	@ movhi
 632:../SPL/src/stm32f10x_usart.c **** }
 2048              		.loc 1 632 0
 2049 0c76 07F10807 		add	r7, r7, #8
 2050 0c7a BD46     		mov	sp, r7
 2051 0c7c 80BD     		pop	{r7, pc}
 2052              	.L111:
 2053 0c7e 00BF     		.align	2
 2054              	.L110:
 2055 0c80 00380140 		.word	1073821696
 2056 0c84 00440040 		.word	1073759232
 2057 0c88 00480040 		.word	1073760256
 2058 0c8c 004C0040 		.word	1073761280
 2059 0c90 00500040 		.word	1073762304
 2060 0c94 00000000 		.word	.LC0
 2061              		.cfi_endproc
 2062              	.LFE44:
 2064              		.align	2
 2065              		.global	USART_SetGuardTime
 2066              		.thumb
 2067              		.thumb_func
 2069              	USART_SetGuardTime:
 2070              	.LFB45:
 633:../SPL/src/stm32f10x_usart.c **** 
 634:../SPL/src/stm32f10x_usart.c **** /**
 635:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the specified USART guard time.
 636:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
 637:../SPL/src/stm32f10x_usart.c ****   * @param  USART_GuardTime: specifies the guard time.
 638:../SPL/src/stm32f10x_usart.c ****   * @note The guard time bits are not available for UART4 and UART5.   
 639:../SPL/src/stm32f10x_usart.c ****   * @retval None
 640:../SPL/src/stm32f10x_usart.c ****   */
 641:../SPL/src/stm32f10x_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
 642:../SPL/src/stm32f10x_usart.c **** {    
 2071              		.loc 1 642 0
 2072              		.cfi_startproc
 2073              		@ args = 0, pretend = 0, frame = 8
 2074              		@ frame_needed = 1, uses_anonymous_args = 0
 2075 0c98 80B5     		push	{r7, lr}
 2076              	.LCFI48:
 2077              		.cfi_def_cfa_offset 8
 2078              		.cfi_offset 7, -8
 2079              		.cfi_offset 14, -4
 2080 0c9a 82B0     		sub	sp, sp, #8
 2081              	.LCFI49:
 2082              		.cfi_def_cfa_offset 16
 2083 0c9c 00AF     		add	r7, sp, #0
 2084              	.LCFI50:
 2085              		.cfi_def_cfa_register 7
 2086 0c9e 7860     		str	r0, [r7, #4]
 2087 0ca0 0B46     		mov	r3, r1
 2088 0ca2 FB70     		strb	r3, [r7, #3]
 643:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 644:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 2089              		.loc 1 644 0
 2090 0ca4 7A68     		ldr	r2, [r7, #4]
 2091 0ca6 134B     		ldr	r3, .L114
 2092 0ca8 9A42     		cmp	r2, r3
 2093 0caa 0CD0     		beq	.L113
 2094              		.loc 1 644 0 is_stmt 0 discriminator 1
 2095 0cac 7A68     		ldr	r2, [r7, #4]
 2096 0cae 124B     		ldr	r3, .L114+4
 2097 0cb0 9A42     		cmp	r2, r3
 2098 0cb2 08D0     		beq	.L113
 2099              		.loc 1 644 0 discriminator 2
 2100 0cb4 7A68     		ldr	r2, [r7, #4]
 2101 0cb6 114B     		ldr	r3, .L114+8
 2102 0cb8 9A42     		cmp	r2, r3
 2103 0cba 04D0     		beq	.L113
 2104              		.loc 1 644 0 discriminator 3
 2105 0cbc 1048     		ldr	r0, .L114+12
 2106 0cbe 4FF42171 		mov	r1, #644
 2107 0cc2 FFF7FEFF 		bl	assert_failed
 2108              	.L113:
 645:../SPL/src/stm32f10x_usart.c ****   
 646:../SPL/src/stm32f10x_usart.c ****   /* Clear the USART Guard time */
 647:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR &= GTPR_LSB_Mask;
 2109              		.loc 1 647 0 is_stmt 1
 2110 0cc6 7B68     		ldr	r3, [r7, #4]
 2111 0cc8 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2112 0cca 9BB2     		uxth	r3, r3
 2113 0ccc DBB2     		uxtb	r3, r3
 2114 0cce 9AB2     		uxth	r2, r3
 2115 0cd0 7B68     		ldr	r3, [r7, #4]
 2116 0cd2 1A83     		strh	r2, [r3, #24]	@ movhi
 648:../SPL/src/stm32f10x_usart.c ****   /* Set the USART guard time */
 649:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 2117              		.loc 1 649 0
 2118 0cd4 7B68     		ldr	r3, [r7, #4]
 2119 0cd6 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2120 0cd8 9AB2     		uxth	r2, r3
 2121 0cda FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2122 0cdc 9BB2     		uxth	r3, r3
 2123 0cde 4FEA0323 		lsl	r3, r3, #8
 2124 0ce2 9BB2     		uxth	r3, r3
 2125 0ce4 1343     		orrs	r3, r3, r2
 2126 0ce6 9AB2     		uxth	r2, r3
 2127 0ce8 7B68     		ldr	r3, [r7, #4]
 2128 0cea 1A83     		strh	r2, [r3, #24]	@ movhi
 650:../SPL/src/stm32f10x_usart.c **** }
 2129              		.loc 1 650 0
 2130 0cec 07F10807 		add	r7, r7, #8
 2131 0cf0 BD46     		mov	sp, r7
 2132 0cf2 80BD     		pop	{r7, pc}
 2133              	.L115:
 2134              		.align	2
 2135              	.L114:
 2136 0cf4 00380140 		.word	1073821696
 2137 0cf8 00440040 		.word	1073759232
 2138 0cfc 00480040 		.word	1073760256
 2139 0d00 00000000 		.word	.LC0
 2140              		.cfi_endproc
 2141              	.LFE45:
 2143              		.align	2
 2144              		.global	USART_SetPrescaler
 2145              		.thumb
 2146              		.thumb_func
 2148              	USART_SetPrescaler:
 2149              	.LFB46:
 651:../SPL/src/stm32f10x_usart.c **** 
 652:../SPL/src/stm32f10x_usart.c **** /**
 653:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the system clock prescaler.
 654:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 655:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 656:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 657:../SPL/src/stm32f10x_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock.  
 658:../SPL/src/stm32f10x_usart.c ****   * @note   The function is used for IrDA mode with UART4 and UART5.
 659:../SPL/src/stm32f10x_usart.c ****   * @retval None
 660:../SPL/src/stm32f10x_usart.c ****   */
 661:../SPL/src/stm32f10x_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 662:../SPL/src/stm32f10x_usart.c **** { 
 2150              		.loc 1 662 0
 2151              		.cfi_startproc
 2152              		@ args = 0, pretend = 0, frame = 8
 2153              		@ frame_needed = 1, uses_anonymous_args = 0
 2154 0d04 80B5     		push	{r7, lr}
 2155              	.LCFI51:
 2156              		.cfi_def_cfa_offset 8
 2157              		.cfi_offset 7, -8
 2158              		.cfi_offset 14, -4
 2159 0d06 82B0     		sub	sp, sp, #8
 2160              	.LCFI52:
 2161              		.cfi_def_cfa_offset 16
 2162 0d08 00AF     		add	r7, sp, #0
 2163              	.LCFI53:
 2164              		.cfi_def_cfa_register 7
 2165 0d0a 7860     		str	r0, [r7, #4]
 2166 0d0c 0B46     		mov	r3, r1
 2167 0d0e FB70     		strb	r3, [r7, #3]
 663:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 664:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2168              		.loc 1 664 0
 2169 0d10 7A68     		ldr	r2, [r7, #4]
 2170 0d12 164B     		ldr	r3, .L118
 2171 0d14 9A42     		cmp	r2, r3
 2172 0d16 14D0     		beq	.L117
 2173              		.loc 1 664 0 is_stmt 0 discriminator 1
 2174 0d18 7A68     		ldr	r2, [r7, #4]
 2175 0d1a 154B     		ldr	r3, .L118+4
 2176 0d1c 9A42     		cmp	r2, r3
 2177 0d1e 10D0     		beq	.L117
 2178              		.loc 1 664 0 discriminator 2
 2179 0d20 7A68     		ldr	r2, [r7, #4]
 2180 0d22 144B     		ldr	r3, .L118+8
 2181 0d24 9A42     		cmp	r2, r3
 2182 0d26 0CD0     		beq	.L117
 2183              		.loc 1 664 0 discriminator 3
 2184 0d28 7A68     		ldr	r2, [r7, #4]
 2185 0d2a 134B     		ldr	r3, .L118+12
 2186 0d2c 9A42     		cmp	r2, r3
 2187 0d2e 08D0     		beq	.L117
 2188              		.loc 1 664 0 discriminator 4
 2189 0d30 7A68     		ldr	r2, [r7, #4]
 2190 0d32 124B     		ldr	r3, .L118+16
 2191 0d34 9A42     		cmp	r2, r3
 2192 0d36 04D0     		beq	.L117
 2193              		.loc 1 664 0 discriminator 5
 2194 0d38 1148     		ldr	r0, .L118+20
 2195 0d3a 4FF42671 		mov	r1, #664
 2196 0d3e FFF7FEFF 		bl	assert_failed
 2197              	.L117:
 665:../SPL/src/stm32f10x_usart.c ****   
 666:../SPL/src/stm32f10x_usart.c ****   /* Clear the USART prescaler */
 667:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR &= GTPR_MSB_Mask;
 2198              		.loc 1 667 0 is_stmt 1
 2199 0d42 7B68     		ldr	r3, [r7, #4]
 2200 0d44 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2201 0d46 9BB2     		uxth	r3, r3
 2202 0d48 23F0FF03 		bic	r3, r3, #255
 2203 0d4c 9AB2     		uxth	r2, r3
 2204 0d4e 7B68     		ldr	r3, [r7, #4]
 2205 0d50 1A83     		strh	r2, [r3, #24]	@ movhi
 668:../SPL/src/stm32f10x_usart.c ****   /* Set the USART prescaler */
 669:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 2206              		.loc 1 669 0
 2207 0d52 7B68     		ldr	r3, [r7, #4]
 2208 0d54 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2209 0d56 9AB2     		uxth	r2, r3
 2210 0d58 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2211 0d5a 9BB2     		uxth	r3, r3
 2212 0d5c 1343     		orrs	r3, r3, r2
 2213 0d5e 9AB2     		uxth	r2, r3
 2214 0d60 7B68     		ldr	r3, [r7, #4]
 2215 0d62 1A83     		strh	r2, [r3, #24]	@ movhi
 670:../SPL/src/stm32f10x_usart.c **** }
 2216              		.loc 1 670 0
 2217 0d64 07F10807 		add	r7, r7, #8
 2218 0d68 BD46     		mov	sp, r7
 2219 0d6a 80BD     		pop	{r7, pc}
 2220              	.L119:
 2221              		.align	2
 2222              	.L118:
 2223 0d6c 00380140 		.word	1073821696
 2224 0d70 00440040 		.word	1073759232
 2225 0d74 00480040 		.word	1073760256
 2226 0d78 004C0040 		.word	1073761280
 2227 0d7c 00500040 		.word	1073762304
 2228 0d80 00000000 		.word	.LC0
 2229              		.cfi_endproc
 2230              	.LFE46:
 2232              		.align	2
 2233              		.global	USART_SmartCardCmd
 2234              		.thumb
 2235              		.thumb_func
 2237              	USART_SmartCardCmd:
 2238              	.LFB47:
 671:../SPL/src/stm32f10x_usart.c **** 
 672:../SPL/src/stm32f10x_usart.c **** /**
 673:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs Smart Card mode.
 674:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
 675:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the Smart Card mode.
 676:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.     
 677:../SPL/src/stm32f10x_usart.c ****   * @note The Smart Card mode is not available for UART4 and UART5. 
 678:../SPL/src/stm32f10x_usart.c ****   * @retval None
 679:../SPL/src/stm32f10x_usart.c ****   */
 680:../SPL/src/stm32f10x_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 681:../SPL/src/stm32f10x_usart.c **** {
 2239              		.loc 1 681 0
 2240              		.cfi_startproc
 2241              		@ args = 0, pretend = 0, frame = 8
 2242              		@ frame_needed = 1, uses_anonymous_args = 0
 2243 0d84 80B5     		push	{r7, lr}
 2244              	.LCFI54:
 2245              		.cfi_def_cfa_offset 8
 2246              		.cfi_offset 7, -8
 2247              		.cfi_offset 14, -4
 2248 0d86 82B0     		sub	sp, sp, #8
 2249              	.LCFI55:
 2250              		.cfi_def_cfa_offset 16
 2251 0d88 00AF     		add	r7, sp, #0
 2252              	.LCFI56:
 2253              		.cfi_def_cfa_register 7
 2254 0d8a 7860     		str	r0, [r7, #4]
 2255 0d8c 0B46     		mov	r3, r1
 2256 0d8e FB70     		strb	r3, [r7, #3]
 682:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 683:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 2257              		.loc 1 683 0
 2258 0d90 7A68     		ldr	r2, [r7, #4]
 2259 0d92 194B     		ldr	r3, .L125
 2260 0d94 9A42     		cmp	r2, r3
 2261 0d96 0CD0     		beq	.L121
 2262              		.loc 1 683 0 is_stmt 0 discriminator 1
 2263 0d98 7A68     		ldr	r2, [r7, #4]
 2264 0d9a 184B     		ldr	r3, .L125+4
 2265 0d9c 9A42     		cmp	r2, r3
 2266 0d9e 08D0     		beq	.L121
 2267              		.loc 1 683 0 discriminator 2
 2268 0da0 7A68     		ldr	r2, [r7, #4]
 2269 0da2 174B     		ldr	r3, .L125+8
 2270 0da4 9A42     		cmp	r2, r3
 2271 0da6 04D0     		beq	.L121
 2272              		.loc 1 683 0 discriminator 3
 2273 0da8 1648     		ldr	r0, .L125+12
 2274 0daa 40F2AB21 		movw	r1, #683
 2275 0dae FFF7FEFF 		bl	assert_failed
 2276              	.L121:
 684:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 2277              		.loc 1 684 0 is_stmt 1
 2278 0db2 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2279 0db4 002B     		cmp	r3, #0
 2280 0db6 07D0     		beq	.L122
 2281              		.loc 1 684 0 is_stmt 0 discriminator 1
 2282 0db8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2283 0dba 012B     		cmp	r3, #1
 2284 0dbc 04D0     		beq	.L122
 2285              		.loc 1 684 0 discriminator 2
 2286 0dbe 1148     		ldr	r0, .L125+12
 2287 0dc0 4FF42B71 		mov	r1, #684
 2288 0dc4 FFF7FEFF 		bl	assert_failed
 2289              	.L122:
 685:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 2290              		.loc 1 685 0 is_stmt 1
 2291 0dc8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2292 0dca 002B     		cmp	r3, #0
 2293 0dcc 08D0     		beq	.L123
 686:../SPL/src/stm32f10x_usart.c ****   {
 687:../SPL/src/stm32f10x_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
 688:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_SCEN_Set;
 2294              		.loc 1 688 0
 2295 0dce 7B68     		ldr	r3, [r7, #4]
 2296 0dd0 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2297 0dd2 9BB2     		uxth	r3, r3
 2298 0dd4 43F02003 		orr	r3, r3, #32
 2299 0dd8 9AB2     		uxth	r2, r3
 2300 0dda 7B68     		ldr	r3, [r7, #4]
 2301 0ddc 9A82     		strh	r2, [r3, #20]	@ movhi
 2302 0dde 07E0     		b	.L120
 2303              	.L123:
 689:../SPL/src/stm32f10x_usart.c ****   }
 690:../SPL/src/stm32f10x_usart.c ****   else
 691:../SPL/src/stm32f10x_usart.c ****   {
 692:../SPL/src/stm32f10x_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
 693:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_SCEN_Reset;
 2304              		.loc 1 693 0
 2305 0de0 7B68     		ldr	r3, [r7, #4]
 2306 0de2 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2307 0de4 9BB2     		uxth	r3, r3
 2308 0de6 23F02003 		bic	r3, r3, #32
 2309 0dea 9AB2     		uxth	r2, r3
 2310 0dec 7B68     		ldr	r3, [r7, #4]
 2311 0dee 9A82     		strh	r2, [r3, #20]	@ movhi
 2312              	.L120:
 694:../SPL/src/stm32f10x_usart.c ****   }
 695:../SPL/src/stm32f10x_usart.c **** }
 2313              		.loc 1 695 0
 2314 0df0 07F10807 		add	r7, r7, #8
 2315 0df4 BD46     		mov	sp, r7
 2316 0df6 80BD     		pop	{r7, pc}
 2317              	.L126:
 2318              		.align	2
 2319              	.L125:
 2320 0df8 00380140 		.word	1073821696
 2321 0dfc 00440040 		.word	1073759232
 2322 0e00 00480040 		.word	1073760256
 2323 0e04 00000000 		.word	.LC0
 2324              		.cfi_endproc
 2325              	.LFE47:
 2327              		.align	2
 2328              		.global	USART_SmartCardNACKCmd
 2329              		.thumb
 2330              		.thumb_func
 2332              	USART_SmartCardNACKCmd:
 2333              	.LFB48:
 696:../SPL/src/stm32f10x_usart.c **** 
 697:../SPL/src/stm32f10x_usart.c **** /**
 698:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables NACK transmission.
 699:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral. 
 700:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the NACK transmission.
 701:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.  
 702:../SPL/src/stm32f10x_usart.c ****   * @note The Smart Card mode is not available for UART4 and UART5.
 703:../SPL/src/stm32f10x_usart.c ****   * @retval None
 704:../SPL/src/stm32f10x_usart.c ****   */
 705:../SPL/src/stm32f10x_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 706:../SPL/src/stm32f10x_usart.c **** {
 2334              		.loc 1 706 0
 2335              		.cfi_startproc
 2336              		@ args = 0, pretend = 0, frame = 8
 2337              		@ frame_needed = 1, uses_anonymous_args = 0
 2338 0e08 80B5     		push	{r7, lr}
 2339              	.LCFI57:
 2340              		.cfi_def_cfa_offset 8
 2341              		.cfi_offset 7, -8
 2342              		.cfi_offset 14, -4
 2343 0e0a 82B0     		sub	sp, sp, #8
 2344              	.LCFI58:
 2345              		.cfi_def_cfa_offset 16
 2346 0e0c 00AF     		add	r7, sp, #0
 2347              	.LCFI59:
 2348              		.cfi_def_cfa_register 7
 2349 0e0e 7860     		str	r0, [r7, #4]
 2350 0e10 0B46     		mov	r3, r1
 2351 0e12 FB70     		strb	r3, [r7, #3]
 707:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 708:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));  
 2352              		.loc 1 708 0
 2353 0e14 7A68     		ldr	r2, [r7, #4]
 2354 0e16 194B     		ldr	r3, .L132
 2355 0e18 9A42     		cmp	r2, r3
 2356 0e1a 0CD0     		beq	.L128
 2357              		.loc 1 708 0 is_stmt 0 discriminator 1
 2358 0e1c 7A68     		ldr	r2, [r7, #4]
 2359 0e1e 184B     		ldr	r3, .L132+4
 2360 0e20 9A42     		cmp	r2, r3
 2361 0e22 08D0     		beq	.L128
 2362              		.loc 1 708 0 discriminator 2
 2363 0e24 7A68     		ldr	r2, [r7, #4]
 2364 0e26 174B     		ldr	r3, .L132+8
 2365 0e28 9A42     		cmp	r2, r3
 2366 0e2a 04D0     		beq	.L128
 2367              		.loc 1 708 0 discriminator 3
 2368 0e2c 1648     		ldr	r0, .L132+12
 2369 0e2e 4FF43171 		mov	r1, #708
 2370 0e32 FFF7FEFF 		bl	assert_failed
 2371              	.L128:
 709:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 2372              		.loc 1 709 0 is_stmt 1
 2373 0e36 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2374 0e38 002B     		cmp	r3, #0
 2375 0e3a 07D0     		beq	.L129
 2376              		.loc 1 709 0 is_stmt 0 discriminator 1
 2377 0e3c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2378 0e3e 012B     		cmp	r3, #1
 2379 0e40 04D0     		beq	.L129
 2380              		.loc 1 709 0 discriminator 2
 2381 0e42 1148     		ldr	r0, .L132+12
 2382 0e44 40F2C521 		movw	r1, #709
 2383 0e48 FFF7FEFF 		bl	assert_failed
 2384              	.L129:
 710:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 2385              		.loc 1 710 0 is_stmt 1
 2386 0e4c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2387 0e4e 002B     		cmp	r3, #0
 2388 0e50 08D0     		beq	.L130
 711:../SPL/src/stm32f10x_usart.c ****   {
 712:../SPL/src/stm32f10x_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
 713:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_NACK_Set;
 2389              		.loc 1 713 0
 2390 0e52 7B68     		ldr	r3, [r7, #4]
 2391 0e54 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2392 0e56 9BB2     		uxth	r3, r3
 2393 0e58 43F01003 		orr	r3, r3, #16
 2394 0e5c 9AB2     		uxth	r2, r3
 2395 0e5e 7B68     		ldr	r3, [r7, #4]
 2396 0e60 9A82     		strh	r2, [r3, #20]	@ movhi
 2397 0e62 07E0     		b	.L127
 2398              	.L130:
 714:../SPL/src/stm32f10x_usart.c ****   }
 715:../SPL/src/stm32f10x_usart.c ****   else
 716:../SPL/src/stm32f10x_usart.c ****   {
 717:../SPL/src/stm32f10x_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
 718:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_NACK_Reset;
 2399              		.loc 1 718 0
 2400 0e64 7B68     		ldr	r3, [r7, #4]
 2401 0e66 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2402 0e68 9BB2     		uxth	r3, r3
 2403 0e6a 23F01003 		bic	r3, r3, #16
 2404 0e6e 9AB2     		uxth	r2, r3
 2405 0e70 7B68     		ldr	r3, [r7, #4]
 2406 0e72 9A82     		strh	r2, [r3, #20]	@ movhi
 2407              	.L127:
 719:../SPL/src/stm32f10x_usart.c ****   }
 720:../SPL/src/stm32f10x_usart.c **** }
 2408              		.loc 1 720 0
 2409 0e74 07F10807 		add	r7, r7, #8
 2410 0e78 BD46     		mov	sp, r7
 2411 0e7a 80BD     		pop	{r7, pc}
 2412              	.L133:
 2413              		.align	2
 2414              	.L132:
 2415 0e7c 00380140 		.word	1073821696
 2416 0e80 00440040 		.word	1073759232
 2417 0e84 00480040 		.word	1073760256
 2418 0e88 00000000 		.word	.LC0
 2419              		.cfi_endproc
 2420              	.LFE48:
 2422              		.align	2
 2423              		.global	USART_HalfDuplexCmd
 2424              		.thumb
 2425              		.thumb_func
 2427              	USART_HalfDuplexCmd:
 2428              	.LFB49:
 721:../SPL/src/stm32f10x_usart.c **** 
 722:../SPL/src/stm32f10x_usart.c **** /**
 723:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs Half Duplex communication.
 724:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 725:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 726:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 727:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART Communication.
 728:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 729:../SPL/src/stm32f10x_usart.c ****   * @retval None
 730:../SPL/src/stm32f10x_usart.c ****   */
 731:../SPL/src/stm32f10x_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 732:../SPL/src/stm32f10x_usart.c **** {
 2429              		.loc 1 732 0
 2430              		.cfi_startproc
 2431              		@ args = 0, pretend = 0, frame = 8
 2432              		@ frame_needed = 1, uses_anonymous_args = 0
 2433 0e8c 80B5     		push	{r7, lr}
 2434              	.LCFI60:
 2435              		.cfi_def_cfa_offset 8
 2436              		.cfi_offset 7, -8
 2437              		.cfi_offset 14, -4
 2438 0e8e 82B0     		sub	sp, sp, #8
 2439              	.LCFI61:
 2440              		.cfi_def_cfa_offset 16
 2441 0e90 00AF     		add	r7, sp, #0
 2442              	.LCFI62:
 2443              		.cfi_def_cfa_register 7
 2444 0e92 7860     		str	r0, [r7, #4]
 2445 0e94 0B46     		mov	r3, r1
 2446 0e96 FB70     		strb	r3, [r7, #3]
 733:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 734:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2447              		.loc 1 734 0
 2448 0e98 7A68     		ldr	r2, [r7, #4]
 2449 0e9a 1D4B     		ldr	r3, .L139
 2450 0e9c 9A42     		cmp	r2, r3
 2451 0e9e 14D0     		beq	.L135
 2452              		.loc 1 734 0 is_stmt 0 discriminator 1
 2453 0ea0 7A68     		ldr	r2, [r7, #4]
 2454 0ea2 1C4B     		ldr	r3, .L139+4
 2455 0ea4 9A42     		cmp	r2, r3
 2456 0ea6 10D0     		beq	.L135
 2457              		.loc 1 734 0 discriminator 2
 2458 0ea8 7A68     		ldr	r2, [r7, #4]
 2459 0eaa 1B4B     		ldr	r3, .L139+8
 2460 0eac 9A42     		cmp	r2, r3
 2461 0eae 0CD0     		beq	.L135
 2462              		.loc 1 734 0 discriminator 3
 2463 0eb0 7A68     		ldr	r2, [r7, #4]
 2464 0eb2 1A4B     		ldr	r3, .L139+12
 2465 0eb4 9A42     		cmp	r2, r3
 2466 0eb6 08D0     		beq	.L135
 2467              		.loc 1 734 0 discriminator 4
 2468 0eb8 7A68     		ldr	r2, [r7, #4]
 2469 0eba 194B     		ldr	r3, .L139+16
 2470 0ebc 9A42     		cmp	r2, r3
 2471 0ebe 04D0     		beq	.L135
 2472              		.loc 1 734 0 discriminator 5
 2473 0ec0 1848     		ldr	r0, .L139+20
 2474 0ec2 40F2DE21 		movw	r1, #734
 2475 0ec6 FFF7FEFF 		bl	assert_failed
 2476              	.L135:
 735:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 2477              		.loc 1 735 0 is_stmt 1
 2478 0eca FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2479 0ecc 002B     		cmp	r3, #0
 2480 0ece 07D0     		beq	.L136
 2481              		.loc 1 735 0 is_stmt 0 discriminator 1
 2482 0ed0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2483 0ed2 012B     		cmp	r3, #1
 2484 0ed4 04D0     		beq	.L136
 2485              		.loc 1 735 0 discriminator 2
 2486 0ed6 1348     		ldr	r0, .L139+20
 2487 0ed8 40F2DF21 		movw	r1, #735
 2488 0edc FFF7FEFF 		bl	assert_failed
 2489              	.L136:
 736:../SPL/src/stm32f10x_usart.c ****   
 737:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 2490              		.loc 1 737 0 is_stmt 1
 2491 0ee0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2492 0ee2 002B     		cmp	r3, #0
 2493 0ee4 08D0     		beq	.L137
 738:../SPL/src/stm32f10x_usart.c ****   {
 739:../SPL/src/stm32f10x_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 740:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_HDSEL_Set;
 2494              		.loc 1 740 0
 2495 0ee6 7B68     		ldr	r3, [r7, #4]
 2496 0ee8 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2497 0eea 9BB2     		uxth	r3, r3
 2498 0eec 43F00803 		orr	r3, r3, #8
 2499 0ef0 9AB2     		uxth	r2, r3
 2500 0ef2 7B68     		ldr	r3, [r7, #4]
 2501 0ef4 9A82     		strh	r2, [r3, #20]	@ movhi
 2502 0ef6 07E0     		b	.L134
 2503              	.L137:
 741:../SPL/src/stm32f10x_usart.c ****   }
 742:../SPL/src/stm32f10x_usart.c ****   else
 743:../SPL/src/stm32f10x_usart.c ****   {
 744:../SPL/src/stm32f10x_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
 745:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_HDSEL_Reset;
 2504              		.loc 1 745 0
 2505 0ef8 7B68     		ldr	r3, [r7, #4]
 2506 0efa 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2507 0efc 9BB2     		uxth	r3, r3
 2508 0efe 23F00803 		bic	r3, r3, #8
 2509 0f02 9AB2     		uxth	r2, r3
 2510 0f04 7B68     		ldr	r3, [r7, #4]
 2511 0f06 9A82     		strh	r2, [r3, #20]	@ movhi
 2512              	.L134:
 746:../SPL/src/stm32f10x_usart.c ****   }
 747:../SPL/src/stm32f10x_usart.c **** }
 2513              		.loc 1 747 0
 2514 0f08 07F10807 		add	r7, r7, #8
 2515 0f0c BD46     		mov	sp, r7
 2516 0f0e 80BD     		pop	{r7, pc}
 2517              	.L140:
 2518              		.align	2
 2519              	.L139:
 2520 0f10 00380140 		.word	1073821696
 2521 0f14 00440040 		.word	1073759232
 2522 0f18 00480040 		.word	1073760256
 2523 0f1c 004C0040 		.word	1073761280
 2524 0f20 00500040 		.word	1073762304
 2525 0f24 00000000 		.word	.LC0
 2526              		.cfi_endproc
 2527              	.LFE49:
 2529              		.align	2
 2530              		.global	USART_OverSampling8Cmd
 2531              		.thumb
 2532              		.thumb_func
 2534              	USART_OverSampling8Cmd:
 2535              	.LFB50:
 748:../SPL/src/stm32f10x_usart.c **** 
 749:../SPL/src/stm32f10x_usart.c **** 
 750:../SPL/src/stm32f10x_usart.c **** /**
 751:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 752:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral.
 753:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 754:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 755:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 756:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 757:../SPL/src/stm32f10x_usart.c ****   * @note
 758:../SPL/src/stm32f10x_usart.c ****   *     This function has to be called before calling USART_Init()
 759:../SPL/src/stm32f10x_usart.c ****   *     function in order to have correct baudrate Divider value.   
 760:../SPL/src/stm32f10x_usart.c ****   * @retval None
 761:../SPL/src/stm32f10x_usart.c ****   */
 762:../SPL/src/stm32f10x_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 763:../SPL/src/stm32f10x_usart.c **** {
 2536              		.loc 1 763 0
 2537              		.cfi_startproc
 2538              		@ args = 0, pretend = 0, frame = 8
 2539              		@ frame_needed = 1, uses_anonymous_args = 0
 2540 0f28 80B5     		push	{r7, lr}
 2541              	.LCFI63:
 2542              		.cfi_def_cfa_offset 8
 2543              		.cfi_offset 7, -8
 2544              		.cfi_offset 14, -4
 2545 0f2a 82B0     		sub	sp, sp, #8
 2546              	.LCFI64:
 2547              		.cfi_def_cfa_offset 16
 2548 0f2c 00AF     		add	r7, sp, #0
 2549              	.LCFI65:
 2550              		.cfi_def_cfa_register 7
 2551 0f2e 7860     		str	r0, [r7, #4]
 2552 0f30 0B46     		mov	r3, r1
 2553 0f32 FB70     		strb	r3, [r7, #3]
 764:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 765:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2554              		.loc 1 765 0
 2555 0f34 7A68     		ldr	r2, [r7, #4]
 2556 0f36 1F4B     		ldr	r3, .L146
 2557 0f38 9A42     		cmp	r2, r3
 2558 0f3a 14D0     		beq	.L142
 2559              		.loc 1 765 0 is_stmt 0 discriminator 1
 2560 0f3c 7A68     		ldr	r2, [r7, #4]
 2561 0f3e 1E4B     		ldr	r3, .L146+4
 2562 0f40 9A42     		cmp	r2, r3
 2563 0f42 10D0     		beq	.L142
 2564              		.loc 1 765 0 discriminator 2
 2565 0f44 7A68     		ldr	r2, [r7, #4]
 2566 0f46 1D4B     		ldr	r3, .L146+8
 2567 0f48 9A42     		cmp	r2, r3
 2568 0f4a 0CD0     		beq	.L142
 2569              		.loc 1 765 0 discriminator 3
 2570 0f4c 7A68     		ldr	r2, [r7, #4]
 2571 0f4e 1C4B     		ldr	r3, .L146+12
 2572 0f50 9A42     		cmp	r2, r3
 2573 0f52 08D0     		beq	.L142
 2574              		.loc 1 765 0 discriminator 4
 2575 0f54 7A68     		ldr	r2, [r7, #4]
 2576 0f56 1B4B     		ldr	r3, .L146+16
 2577 0f58 9A42     		cmp	r2, r3
 2578 0f5a 04D0     		beq	.L142
 2579              		.loc 1 765 0 discriminator 5
 2580 0f5c 1A48     		ldr	r0, .L146+20
 2581 0f5e 40F2FD21 		movw	r1, #765
 2582 0f62 FFF7FEFF 		bl	assert_failed
 2583              	.L142:
 766:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 2584              		.loc 1 766 0 is_stmt 1
 2585 0f66 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2586 0f68 002B     		cmp	r3, #0
 2587 0f6a 07D0     		beq	.L143
 2588              		.loc 1 766 0 is_stmt 0 discriminator 1
 2589 0f6c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2590 0f6e 012B     		cmp	r3, #1
 2591 0f70 04D0     		beq	.L143
 2592              		.loc 1 766 0 discriminator 2
 2593 0f72 1548     		ldr	r0, .L146+20
 2594 0f74 40F2FE21 		movw	r1, #766
 2595 0f78 FFF7FEFF 		bl	assert_failed
 2596              	.L143:
 767:../SPL/src/stm32f10x_usart.c ****   
 768:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 2597              		.loc 1 768 0 is_stmt 1
 2598 0f7c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2599 0f7e 002B     		cmp	r3, #0
 2600 0f80 0AD0     		beq	.L144
 769:../SPL/src/stm32f10x_usart.c ****   {
 770:../SPL/src/stm32f10x_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 771:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_OVER8_Set;
 2601              		.loc 1 771 0
 2602 0f82 7B68     		ldr	r3, [r7, #4]
 2603 0f84 9B89     		ldrh	r3, [r3, #12]	@ movhi
 2604 0f86 9BB2     		uxth	r3, r3
 2605 0f88 6FEA4343 		mvn	r3, r3, lsl #17
 2606 0f8c 6FEA5343 		mvn	r3, r3, lsr #17
 2607 0f90 9AB2     		uxth	r2, r3
 2608 0f92 7B68     		ldr	r3, [r7, #4]
 2609 0f94 9A81     		strh	r2, [r3, #12]	@ movhi
 2610 0f96 09E0     		b	.L141
 2611              	.L144:
 772:../SPL/src/stm32f10x_usart.c ****   }
 773:../SPL/src/stm32f10x_usart.c ****   else
 774:../SPL/src/stm32f10x_usart.c ****   {
 775:../SPL/src/stm32f10x_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 776:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_OVER8_Reset;
 2612              		.loc 1 776 0
 2613 0f98 7B68     		ldr	r3, [r7, #4]
 2614 0f9a 9B89     		ldrh	r3, [r3, #12]	@ movhi
 2615 0f9c 9BB2     		uxth	r3, r3
 2616 0f9e 4FEA4343 		lsl	r3, r3, #17
 2617 0fa2 4FEA5343 		lsr	r3, r3, #17
 2618 0fa6 9AB2     		uxth	r2, r3
 2619 0fa8 7B68     		ldr	r3, [r7, #4]
 2620 0faa 9A81     		strh	r2, [r3, #12]	@ movhi
 2621              	.L141:
 777:../SPL/src/stm32f10x_usart.c ****   }
 778:../SPL/src/stm32f10x_usart.c **** }
 2622              		.loc 1 778 0
 2623 0fac 07F10807 		add	r7, r7, #8
 2624 0fb0 BD46     		mov	sp, r7
 2625 0fb2 80BD     		pop	{r7, pc}
 2626              	.L147:
 2627              		.align	2
 2628              	.L146:
 2629 0fb4 00380140 		.word	1073821696
 2630 0fb8 00440040 		.word	1073759232
 2631 0fbc 00480040 		.word	1073760256
 2632 0fc0 004C0040 		.word	1073761280
 2633 0fc4 00500040 		.word	1073762304
 2634 0fc8 00000000 		.word	.LC0
 2635              		.cfi_endproc
 2636              	.LFE50:
 2638              		.align	2
 2639              		.global	USART_OneBitMethodCmd
 2640              		.thumb
 2641              		.thumb_func
 2643              	USART_OneBitMethodCmd:
 2644              	.LFB51:
 779:../SPL/src/stm32f10x_usart.c **** 
 780:../SPL/src/stm32f10x_usart.c **** /**
 781:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 782:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral.
 783:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 784:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 785:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 786:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 787:../SPL/src/stm32f10x_usart.c ****   * @retval None
 788:../SPL/src/stm32f10x_usart.c ****   */
 789:../SPL/src/stm32f10x_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 790:../SPL/src/stm32f10x_usart.c **** {
 2645              		.loc 1 790 0
 2646              		.cfi_startproc
 2647              		@ args = 0, pretend = 0, frame = 8
 2648              		@ frame_needed = 1, uses_anonymous_args = 0
 2649 0fcc 80B5     		push	{r7, lr}
 2650              	.LCFI66:
 2651              		.cfi_def_cfa_offset 8
 2652              		.cfi_offset 7, -8
 2653              		.cfi_offset 14, -4
 2654 0fce 82B0     		sub	sp, sp, #8
 2655              	.LCFI67:
 2656              		.cfi_def_cfa_offset 16
 2657 0fd0 00AF     		add	r7, sp, #0
 2658              	.LCFI68:
 2659              		.cfi_def_cfa_register 7
 2660 0fd2 7860     		str	r0, [r7, #4]
 2661 0fd4 0B46     		mov	r3, r1
 2662 0fd6 FB70     		strb	r3, [r7, #3]
 791:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 792:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2663              		.loc 1 792 0
 2664 0fd8 7A68     		ldr	r2, [r7, #4]
 2665 0fda 1D4B     		ldr	r3, .L153
 2666 0fdc 9A42     		cmp	r2, r3
 2667 0fde 14D0     		beq	.L149
 2668              		.loc 1 792 0 is_stmt 0 discriminator 1
 2669 0fe0 7A68     		ldr	r2, [r7, #4]
 2670 0fe2 1C4B     		ldr	r3, .L153+4
 2671 0fe4 9A42     		cmp	r2, r3
 2672 0fe6 10D0     		beq	.L149
 2673              		.loc 1 792 0 discriminator 2
 2674 0fe8 7A68     		ldr	r2, [r7, #4]
 2675 0fea 1B4B     		ldr	r3, .L153+8
 2676 0fec 9A42     		cmp	r2, r3
 2677 0fee 0CD0     		beq	.L149
 2678              		.loc 1 792 0 discriminator 3
 2679 0ff0 7A68     		ldr	r2, [r7, #4]
 2680 0ff2 1A4B     		ldr	r3, .L153+12
 2681 0ff4 9A42     		cmp	r2, r3
 2682 0ff6 08D0     		beq	.L149
 2683              		.loc 1 792 0 discriminator 4
 2684 0ff8 7A68     		ldr	r2, [r7, #4]
 2685 0ffa 194B     		ldr	r3, .L153+16
 2686 0ffc 9A42     		cmp	r2, r3
 2687 0ffe 04D0     		beq	.L149
 2688              		.loc 1 792 0 discriminator 5
 2689 1000 1848     		ldr	r0, .L153+20
 2690 1002 4FF44671 		mov	r1, #792
 2691 1006 FFF7FEFF 		bl	assert_failed
 2692              	.L149:
 793:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 2693              		.loc 1 793 0 is_stmt 1
 2694 100a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2695 100c 002B     		cmp	r3, #0
 2696 100e 07D0     		beq	.L150
 2697              		.loc 1 793 0 is_stmt 0 discriminator 1
 2698 1010 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2699 1012 012B     		cmp	r3, #1
 2700 1014 04D0     		beq	.L150
 2701              		.loc 1 793 0 discriminator 2
 2702 1016 1348     		ldr	r0, .L153+20
 2703 1018 40F21931 		movw	r1, #793
 2704 101c FFF7FEFF 		bl	assert_failed
 2705              	.L150:
 794:../SPL/src/stm32f10x_usart.c ****   
 795:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 2706              		.loc 1 795 0 is_stmt 1
 2707 1020 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2708 1022 002B     		cmp	r3, #0
 2709 1024 08D0     		beq	.L151
 796:../SPL/src/stm32f10x_usart.c ****   {
 797:../SPL/src/stm32f10x_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 798:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_ONEBITE_Set;
 2710              		.loc 1 798 0
 2711 1026 7B68     		ldr	r3, [r7, #4]
 2712 1028 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2713 102a 9BB2     		uxth	r3, r3
 2714 102c 43F40063 		orr	r3, r3, #2048
 2715 1030 9AB2     		uxth	r2, r3
 2716 1032 7B68     		ldr	r3, [r7, #4]
 2717 1034 9A82     		strh	r2, [r3, #20]	@ movhi
 2718 1036 07E0     		b	.L148
 2719              	.L151:
 799:../SPL/src/stm32f10x_usart.c ****   }
 800:../SPL/src/stm32f10x_usart.c ****   else
 801:../SPL/src/stm32f10x_usart.c ****   {
 802:../SPL/src/stm32f10x_usart.c ****     /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
 803:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_ONEBITE_Reset;
 2720              		.loc 1 803 0
 2721 1038 7B68     		ldr	r3, [r7, #4]
 2722 103a 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2723 103c 9BB2     		uxth	r3, r3
 2724 103e 23F40063 		bic	r3, r3, #2048
 2725 1042 9AB2     		uxth	r2, r3
 2726 1044 7B68     		ldr	r3, [r7, #4]
 2727 1046 9A82     		strh	r2, [r3, #20]	@ movhi
 2728              	.L148:
 804:../SPL/src/stm32f10x_usart.c ****   }
 805:../SPL/src/stm32f10x_usart.c **** }
 2729              		.loc 1 805 0
 2730 1048 07F10807 		add	r7, r7, #8
 2731 104c BD46     		mov	sp, r7
 2732 104e 80BD     		pop	{r7, pc}
 2733              	.L154:
 2734              		.align	2
 2735              	.L153:
 2736 1050 00380140 		.word	1073821696
 2737 1054 00440040 		.word	1073759232
 2738 1058 00480040 		.word	1073760256
 2739 105c 004C0040 		.word	1073761280
 2740 1060 00500040 		.word	1073762304
 2741 1064 00000000 		.word	.LC0
 2742              		.cfi_endproc
 2743              	.LFE51:
 2745              		.align	2
 2746              		.global	USART_IrDAConfig
 2747              		.thumb
 2748              		.thumb_func
 2750              	USART_IrDAConfig:
 2751              	.LFB52:
 806:../SPL/src/stm32f10x_usart.c **** 
 807:../SPL/src/stm32f10x_usart.c **** /**
 808:../SPL/src/stm32f10x_usart.c ****   * @brief  Configures the USART's IrDA interface.
 809:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 810:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 811:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 812:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
 813:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 814:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IrDAMode_LowPower
 815:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IrDAMode_Normal
 816:../SPL/src/stm32f10x_usart.c ****   * @retval None
 817:../SPL/src/stm32f10x_usart.c ****   */
 818:../SPL/src/stm32f10x_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
 819:../SPL/src/stm32f10x_usart.c **** {
 2752              		.loc 1 819 0
 2753              		.cfi_startproc
 2754              		@ args = 0, pretend = 0, frame = 8
 2755              		@ frame_needed = 1, uses_anonymous_args = 0
 2756 1068 80B5     		push	{r7, lr}
 2757              	.LCFI69:
 2758              		.cfi_def_cfa_offset 8
 2759              		.cfi_offset 7, -8
 2760              		.cfi_offset 14, -4
 2761 106a 82B0     		sub	sp, sp, #8
 2762              	.LCFI70:
 2763              		.cfi_def_cfa_offset 16
 2764 106c 00AF     		add	r7, sp, #0
 2765              	.LCFI71:
 2766              		.cfi_def_cfa_register 7
 2767 106e 7860     		str	r0, [r7, #4]
 2768 1070 0B46     		mov	r3, r1
 2769 1072 7B80     		strh	r3, [r7, #2]	@ movhi
 820:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 821:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2770              		.loc 1 821 0
 2771 1074 7A68     		ldr	r2, [r7, #4]
 2772 1076 1B4B     		ldr	r3, .L158
 2773 1078 9A42     		cmp	r2, r3
 2774 107a 14D0     		beq	.L156
 2775              		.loc 1 821 0 is_stmt 0 discriminator 1
 2776 107c 7A68     		ldr	r2, [r7, #4]
 2777 107e 1A4B     		ldr	r3, .L158+4
 2778 1080 9A42     		cmp	r2, r3
 2779 1082 10D0     		beq	.L156
 2780              		.loc 1 821 0 discriminator 2
 2781 1084 7A68     		ldr	r2, [r7, #4]
 2782 1086 194B     		ldr	r3, .L158+8
 2783 1088 9A42     		cmp	r2, r3
 2784 108a 0CD0     		beq	.L156
 2785              		.loc 1 821 0 discriminator 3
 2786 108c 7A68     		ldr	r2, [r7, #4]
 2787 108e 184B     		ldr	r3, .L158+12
 2788 1090 9A42     		cmp	r2, r3
 2789 1092 08D0     		beq	.L156
 2790              		.loc 1 821 0 discriminator 4
 2791 1094 7A68     		ldr	r2, [r7, #4]
 2792 1096 174B     		ldr	r3, .L158+16
 2793 1098 9A42     		cmp	r2, r3
 2794 109a 04D0     		beq	.L156
 2795              		.loc 1 821 0 discriminator 5
 2796 109c 1648     		ldr	r0, .L158+20
 2797 109e 40F23531 		movw	r1, #821
 2798 10a2 FFF7FEFF 		bl	assert_failed
 2799              	.L156:
 822:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
 2800              		.loc 1 822 0 is_stmt 1
 2801 10a6 7B88     		ldrh	r3, [r7, #2]
 2802 10a8 042B     		cmp	r3, #4
 2803 10aa 07D0     		beq	.L157
 2804              		.loc 1 822 0 is_stmt 0 discriminator 1
 2805 10ac 7B88     		ldrh	r3, [r7, #2]
 2806 10ae 002B     		cmp	r3, #0
 2807 10b0 04D0     		beq	.L157
 2808              		.loc 1 822 0 discriminator 2
 2809 10b2 1148     		ldr	r0, .L158+20
 2810 10b4 40F23631 		movw	r1, #822
 2811 10b8 FFF7FEFF 		bl	assert_failed
 2812              	.L157:
 823:../SPL/src/stm32f10x_usart.c ****     
 824:../SPL/src/stm32f10x_usart.c ****   USARTx->CR3 &= CR3_IRLP_Mask;
 2813              		.loc 1 824 0 is_stmt 1
 2814 10bc 7B68     		ldr	r3, [r7, #4]
 2815 10be 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2816 10c0 9BB2     		uxth	r3, r3
 2817 10c2 23F00403 		bic	r3, r3, #4
 2818 10c6 9AB2     		uxth	r2, r3
 2819 10c8 7B68     		ldr	r3, [r7, #4]
 2820 10ca 9A82     		strh	r2, [r3, #20]	@ movhi
 825:../SPL/src/stm32f10x_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 2821              		.loc 1 825 0
 2822 10cc 7B68     		ldr	r3, [r7, #4]
 2823 10ce 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2824 10d0 9AB2     		uxth	r2, r3
 2825 10d2 7B88     		ldrh	r3, [r7, #2]	@ movhi
 2826 10d4 1343     		orrs	r3, r3, r2
 2827 10d6 9AB2     		uxth	r2, r3
 2828 10d8 7B68     		ldr	r3, [r7, #4]
 2829 10da 9A82     		strh	r2, [r3, #20]	@ movhi
 826:../SPL/src/stm32f10x_usart.c **** }
 2830              		.loc 1 826 0
 2831 10dc 07F10807 		add	r7, r7, #8
 2832 10e0 BD46     		mov	sp, r7
 2833 10e2 80BD     		pop	{r7, pc}
 2834              	.L159:
 2835              		.align	2
 2836              	.L158:
 2837 10e4 00380140 		.word	1073821696
 2838 10e8 00440040 		.word	1073759232
 2839 10ec 00480040 		.word	1073760256
 2840 10f0 004C0040 		.word	1073761280
 2841 10f4 00500040 		.word	1073762304
 2842 10f8 00000000 		.word	.LC0
 2843              		.cfi_endproc
 2844              	.LFE52:
 2846              		.align	2
 2847              		.global	USART_IrDACmd
 2848              		.thumb
 2849              		.thumb_func
 2851              	USART_IrDACmd:
 2852              	.LFB53:
 827:../SPL/src/stm32f10x_usart.c **** 
 828:../SPL/src/stm32f10x_usart.c **** /**
 829:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USART's IrDA interface.
 830:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 831:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 832:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 833:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the IrDA mode.
 834:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 835:../SPL/src/stm32f10x_usart.c ****   * @retval None
 836:../SPL/src/stm32f10x_usart.c ****   */
 837:../SPL/src/stm32f10x_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
 838:../SPL/src/stm32f10x_usart.c **** {
 2853              		.loc 1 838 0
 2854              		.cfi_startproc
 2855              		@ args = 0, pretend = 0, frame = 8
 2856              		@ frame_needed = 1, uses_anonymous_args = 0
 2857 10fc 80B5     		push	{r7, lr}
 2858              	.LCFI72:
 2859              		.cfi_def_cfa_offset 8
 2860              		.cfi_offset 7, -8
 2861              		.cfi_offset 14, -4
 2862 10fe 82B0     		sub	sp, sp, #8
 2863              	.LCFI73:
 2864              		.cfi_def_cfa_offset 16
 2865 1100 00AF     		add	r7, sp, #0
 2866              	.LCFI74:
 2867              		.cfi_def_cfa_register 7
 2868 1102 7860     		str	r0, [r7, #4]
 2869 1104 0B46     		mov	r3, r1
 2870 1106 FB70     		strb	r3, [r7, #3]
 839:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 840:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2871              		.loc 1 840 0
 2872 1108 7A68     		ldr	r2, [r7, #4]
 2873 110a 1D4B     		ldr	r3, .L165
 2874 110c 9A42     		cmp	r2, r3
 2875 110e 14D0     		beq	.L161
 2876              		.loc 1 840 0 is_stmt 0 discriminator 1
 2877 1110 7A68     		ldr	r2, [r7, #4]
 2878 1112 1C4B     		ldr	r3, .L165+4
 2879 1114 9A42     		cmp	r2, r3
 2880 1116 10D0     		beq	.L161
 2881              		.loc 1 840 0 discriminator 2
 2882 1118 7A68     		ldr	r2, [r7, #4]
 2883 111a 1B4B     		ldr	r3, .L165+8
 2884 111c 9A42     		cmp	r2, r3
 2885 111e 0CD0     		beq	.L161
 2886              		.loc 1 840 0 discriminator 3
 2887 1120 7A68     		ldr	r2, [r7, #4]
 2888 1122 1A4B     		ldr	r3, .L165+12
 2889 1124 9A42     		cmp	r2, r3
 2890 1126 08D0     		beq	.L161
 2891              		.loc 1 840 0 discriminator 4
 2892 1128 7A68     		ldr	r2, [r7, #4]
 2893 112a 194B     		ldr	r3, .L165+16
 2894 112c 9A42     		cmp	r2, r3
 2895 112e 04D0     		beq	.L161
 2896              		.loc 1 840 0 discriminator 5
 2897 1130 1848     		ldr	r0, .L165+20
 2898 1132 4FF45271 		mov	r1, #840
 2899 1136 FFF7FEFF 		bl	assert_failed
 2900              	.L161:
 841:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 2901              		.loc 1 841 0 is_stmt 1
 2902 113a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2903 113c 002B     		cmp	r3, #0
 2904 113e 07D0     		beq	.L162
 2905              		.loc 1 841 0 is_stmt 0 discriminator 1
 2906 1140 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2907 1142 012B     		cmp	r3, #1
 2908 1144 04D0     		beq	.L162
 2909              		.loc 1 841 0 discriminator 2
 2910 1146 1348     		ldr	r0, .L165+20
 2911 1148 40F24931 		movw	r1, #841
 2912 114c FFF7FEFF 		bl	assert_failed
 2913              	.L162:
 842:../SPL/src/stm32f10x_usart.c ****     
 843:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 2914              		.loc 1 843 0 is_stmt 1
 2915 1150 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2916 1152 002B     		cmp	r3, #0
 2917 1154 08D0     		beq	.L163
 844:../SPL/src/stm32f10x_usart.c ****   {
 845:../SPL/src/stm32f10x_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
 846:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_IREN_Set;
 2918              		.loc 1 846 0
 2919 1156 7B68     		ldr	r3, [r7, #4]
 2920 1158 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2921 115a 9BB2     		uxth	r3, r3
 2922 115c 43F00203 		orr	r3, r3, #2
 2923 1160 9AB2     		uxth	r2, r3
 2924 1162 7B68     		ldr	r3, [r7, #4]
 2925 1164 9A82     		strh	r2, [r3, #20]	@ movhi
 2926 1166 07E0     		b	.L160
 2927              	.L163:
 847:../SPL/src/stm32f10x_usart.c ****   }
 848:../SPL/src/stm32f10x_usart.c ****   else
 849:../SPL/src/stm32f10x_usart.c ****   {
 850:../SPL/src/stm32f10x_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
 851:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_IREN_Reset;
 2928              		.loc 1 851 0
 2929 1168 7B68     		ldr	r3, [r7, #4]
 2930 116a 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2931 116c 9BB2     		uxth	r3, r3
 2932 116e 23F00203 		bic	r3, r3, #2
 2933 1172 9AB2     		uxth	r2, r3
 2934 1174 7B68     		ldr	r3, [r7, #4]
 2935 1176 9A82     		strh	r2, [r3, #20]	@ movhi
 2936              	.L160:
 852:../SPL/src/stm32f10x_usart.c ****   }
 853:../SPL/src/stm32f10x_usart.c **** }
 2937              		.loc 1 853 0
 2938 1178 07F10807 		add	r7, r7, #8
 2939 117c BD46     		mov	sp, r7
 2940 117e 80BD     		pop	{r7, pc}
 2941              	.L166:
 2942              		.align	2
 2943              	.L165:
 2944 1180 00380140 		.word	1073821696
 2945 1184 00440040 		.word	1073759232
 2946 1188 00480040 		.word	1073760256
 2947 118c 004C0040 		.word	1073761280
 2948 1190 00500040 		.word	1073762304
 2949 1194 00000000 		.word	.LC0
 2950              		.cfi_endproc
 2951              	.LFE53:
 2953              		.align	2
 2954              		.global	USART_GetFlagStatus
 2955              		.thumb
 2956              		.thumb_func
 2958              	USART_GetFlagStatus:
 2959              	.LFB54:
 854:../SPL/src/stm32f10x_usart.c **** 
 855:../SPL/src/stm32f10x_usart.c **** /**
 856:../SPL/src/stm32f10x_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
 857:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 858:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 859:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 860:../SPL/src/stm32f10x_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
 861:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 862:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
 863:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_LBD:  LIN Break detection flag
 864:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_TXE:  Transmit data register empty flag
 865:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_TC:   Transmission Complete flag
 866:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_RXNE: Receive data register not empty flag
 867:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_IDLE: Idle Line detection flag
 868:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_ORE:  OverRun Error flag
 869:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_NE:   Noise Error flag
 870:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_FE:   Framing Error flag
 871:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_PE:   Parity Error flag
 872:../SPL/src/stm32f10x_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
 873:../SPL/src/stm32f10x_usart.c ****   */
 874:../SPL/src/stm32f10x_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
 875:../SPL/src/stm32f10x_usart.c **** {
 2960              		.loc 1 875 0
 2961              		.cfi_startproc
 2962              		@ args = 0, pretend = 0, frame = 16
 2963              		@ frame_needed = 1, uses_anonymous_args = 0
 2964 1198 80B5     		push	{r7, lr}
 2965              	.LCFI75:
 2966              		.cfi_def_cfa_offset 8
 2967              		.cfi_offset 7, -8
 2968              		.cfi_offset 14, -4
 2969 119a 84B0     		sub	sp, sp, #16
 2970              	.LCFI76:
 2971              		.cfi_def_cfa_offset 24
 2972 119c 00AF     		add	r7, sp, #0
 2973              	.LCFI77:
 2974              		.cfi_def_cfa_register 7
 2975 119e 7860     		str	r0, [r7, #4]
 2976 11a0 0B46     		mov	r3, r1
 2977 11a2 7B80     		strh	r3, [r7, #2]	@ movhi
 876:../SPL/src/stm32f10x_usart.c ****   FlagStatus bitstatus = RESET;
 2978              		.loc 1 876 0
 2979 11a4 4FF00003 		mov	r3, #0
 2980 11a8 FB73     		strb	r3, [r7, #15]
 877:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 878:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 2981              		.loc 1 878 0
 2982 11aa 7A68     		ldr	r2, [r7, #4]
 2983 11ac 334B     		ldr	r3, .L174
 2984 11ae 9A42     		cmp	r2, r3
 2985 11b0 14D0     		beq	.L168
 2986              		.loc 1 878 0 is_stmt 0 discriminator 1
 2987 11b2 7A68     		ldr	r2, [r7, #4]
 2988 11b4 324B     		ldr	r3, .L174+4
 2989 11b6 9A42     		cmp	r2, r3
 2990 11b8 10D0     		beq	.L168
 2991              		.loc 1 878 0 discriminator 2
 2992 11ba 7A68     		ldr	r2, [r7, #4]
 2993 11bc 314B     		ldr	r3, .L174+8
 2994 11be 9A42     		cmp	r2, r3
 2995 11c0 0CD0     		beq	.L168
 2996              		.loc 1 878 0 discriminator 3
 2997 11c2 7A68     		ldr	r2, [r7, #4]
 2998 11c4 304B     		ldr	r3, .L174+12
 2999 11c6 9A42     		cmp	r2, r3
 3000 11c8 08D0     		beq	.L168
 3001              		.loc 1 878 0 discriminator 4
 3002 11ca 7A68     		ldr	r2, [r7, #4]
 3003 11cc 2F4B     		ldr	r3, .L174+16
 3004 11ce 9A42     		cmp	r2, r3
 3005 11d0 04D0     		beq	.L168
 3006              		.loc 1 878 0 discriminator 5
 3007 11d2 2F48     		ldr	r0, .L174+20
 3008 11d4 40F26E31 		movw	r1, #878
 3009 11d8 FFF7FEFF 		bl	assert_failed
 3010              	.L168:
 879:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
 3011              		.loc 1 879 0 is_stmt 1
 3012 11dc 7B88     		ldrh	r3, [r7, #2]
 3013 11de 012B     		cmp	r3, #1
 3014 11e0 21D0     		beq	.L169
 3015              		.loc 1 879 0 is_stmt 0 discriminator 1
 3016 11e2 7B88     		ldrh	r3, [r7, #2]
 3017 11e4 802B     		cmp	r3, #128
 3018 11e6 1ED0     		beq	.L169
 3019              		.loc 1 879 0 discriminator 2
 3020 11e8 7B88     		ldrh	r3, [r7, #2]
 3021 11ea 402B     		cmp	r3, #64
 3022 11ec 1BD0     		beq	.L169
 3023              		.loc 1 879 0 discriminator 3
 3024 11ee 7B88     		ldrh	r3, [r7, #2]
 3025 11f0 202B     		cmp	r3, #32
 3026 11f2 18D0     		beq	.L169
 3027              		.loc 1 879 0 discriminator 4
 3028 11f4 7B88     		ldrh	r3, [r7, #2]
 3029 11f6 102B     		cmp	r3, #16
 3030 11f8 15D0     		beq	.L169
 3031              		.loc 1 879 0 discriminator 5
 3032 11fa 7B88     		ldrh	r3, [r7, #2]
 3033 11fc B3F5807F 		cmp	r3, #256
 3034 1200 11D0     		beq	.L169
 3035              		.loc 1 879 0 discriminator 6
 3036 1202 7B88     		ldrh	r3, [r7, #2]
 3037 1204 B3F5007F 		cmp	r3, #512
 3038 1208 0DD0     		beq	.L169
 3039              		.loc 1 879 0 discriminator 7
 3040 120a 7B88     		ldrh	r3, [r7, #2]
 3041 120c 082B     		cmp	r3, #8
 3042 120e 0AD0     		beq	.L169
 3043              		.loc 1 879 0 discriminator 8
 3044 1210 7B88     		ldrh	r3, [r7, #2]
 3045 1212 042B     		cmp	r3, #4
 3046 1214 07D0     		beq	.L169
 3047              		.loc 1 879 0 discriminator 9
 3048 1216 7B88     		ldrh	r3, [r7, #2]
 3049 1218 022B     		cmp	r3, #2
 3050 121a 04D0     		beq	.L169
 3051              		.loc 1 879 0 discriminator 10
 3052 121c 1C48     		ldr	r0, .L174+20
 3053 121e 40F26F31 		movw	r1, #879
 3054 1222 FFF7FEFF 		bl	assert_failed
 3055              	.L169:
 880:../SPL/src/stm32f10x_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
 881:../SPL/src/stm32f10x_usart.c ****   if (USART_FLAG == USART_FLAG_CTS)
 3056              		.loc 1 881 0 is_stmt 1
 3057 1226 7B88     		ldrh	r3, [r7, #2]
 3058 1228 B3F5007F 		cmp	r3, #512
 3059 122c 10D1     		bne	.L170
 882:../SPL/src/stm32f10x_usart.c ****   {
 883:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 3060              		.loc 1 883 0
 3061 122e 7A68     		ldr	r2, [r7, #4]
 3062 1230 124B     		ldr	r3, .L174
 3063 1232 9A42     		cmp	r2, r3
 3064 1234 0CD0     		beq	.L170
 3065              		.loc 1 883 0 is_stmt 0 discriminator 1
 3066 1236 7A68     		ldr	r2, [r7, #4]
 3067 1238 114B     		ldr	r3, .L174+4
 3068 123a 9A42     		cmp	r2, r3
 3069 123c 08D0     		beq	.L170
 3070              		.loc 1 883 0 discriminator 2
 3071 123e 7A68     		ldr	r2, [r7, #4]
 3072 1240 104B     		ldr	r3, .L174+8
 3073 1242 9A42     		cmp	r2, r3
 3074 1244 04D0     		beq	.L170
 3075              		.loc 1 883 0 discriminator 3
 3076 1246 1248     		ldr	r0, .L174+20
 3077 1248 40F27331 		movw	r1, #883
 3078 124c FFF7FEFF 		bl	assert_failed
 3079              	.L170:
 884:../SPL/src/stm32f10x_usart.c ****   }  
 885:../SPL/src/stm32f10x_usart.c ****   
 886:../SPL/src/stm32f10x_usart.c ****   if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 3080              		.loc 1 886 0 is_stmt 1
 3081 1250 7B68     		ldr	r3, [r7, #4]
 3082 1252 1B88     		ldrh	r3, [r3, #0]	@ movhi
 3083 1254 9AB2     		uxth	r2, r3
 3084 1256 7B88     		ldrh	r3, [r7, #2]	@ movhi
 3085 1258 1340     		ands	r3, r3, r2
 3086 125a 9BB2     		uxth	r3, r3
 3087 125c 002B     		cmp	r3, #0
 3088 125e 03D0     		beq	.L171
 887:../SPL/src/stm32f10x_usart.c ****   {
 888:../SPL/src/stm32f10x_usart.c ****     bitstatus = SET;
 3089              		.loc 1 888 0
 3090 1260 4FF00103 		mov	r3, #1
 3091 1264 FB73     		strb	r3, [r7, #15]
 3092 1266 02E0     		b	.L172
 3093              	.L171:
 889:../SPL/src/stm32f10x_usart.c ****   }
 890:../SPL/src/stm32f10x_usart.c ****   else
 891:../SPL/src/stm32f10x_usart.c ****   {
 892:../SPL/src/stm32f10x_usart.c ****     bitstatus = RESET;
 3094              		.loc 1 892 0
 3095 1268 4FF00003 		mov	r3, #0
 3096 126c FB73     		strb	r3, [r7, #15]
 3097              	.L172:
 893:../SPL/src/stm32f10x_usart.c ****   }
 894:../SPL/src/stm32f10x_usart.c ****   return bitstatus;
 3098              		.loc 1 894 0
 3099 126e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 895:../SPL/src/stm32f10x_usart.c **** }
 3100              		.loc 1 895 0
 3101 1270 1846     		mov	r0, r3
 3102 1272 07F11007 		add	r7, r7, #16
 3103 1276 BD46     		mov	sp, r7
 3104 1278 80BD     		pop	{r7, pc}
 3105              	.L175:
 3106 127a 00BF     		.align	2
 3107              	.L174:
 3108 127c 00380140 		.word	1073821696
 3109 1280 00440040 		.word	1073759232
 3110 1284 00480040 		.word	1073760256
 3111 1288 004C0040 		.word	1073761280
 3112 128c 00500040 		.word	1073762304
 3113 1290 00000000 		.word	.LC0
 3114              		.cfi_endproc
 3115              	.LFE54:
 3117              		.align	2
 3118              		.global	USART_ClearFlag
 3119              		.thumb
 3120              		.thumb_func
 3122              	USART_ClearFlag:
 3123              	.LFB55:
 896:../SPL/src/stm32f10x_usart.c **** 
 897:../SPL/src/stm32f10x_usart.c **** /**
 898:../SPL/src/stm32f10x_usart.c ****   * @brief  Clears the USARTx's pending flags.
 899:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 900:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 901:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 902:../SPL/src/stm32f10x_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
 903:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be any combination of the following values:
 904:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
 905:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_LBD:  LIN Break detection flag.
 906:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_TC:   Transmission Complete flag.
 907:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_RXNE: Receive data register not empty flag.
 908:../SPL/src/stm32f10x_usart.c ****   *   
 909:../SPL/src/stm32f10x_usart.c ****   * @note
 910:../SPL/src/stm32f10x_usart.c ****   *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
 911:../SPL/src/stm32f10x_usart.c ****   *     error) and IDLE (Idle line detected) flags are cleared by software 
 912:../SPL/src/stm32f10x_usart.c ****   *     sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
 913:../SPL/src/stm32f10x_usart.c ****   *     followed by a read operation to USART_DR register (USART_ReceiveData()).
 914:../SPL/src/stm32f10x_usart.c ****   *   - RXNE flag can be also cleared by a read to the USART_DR register 
 915:../SPL/src/stm32f10x_usart.c ****   *     (USART_ReceiveData()).
 916:../SPL/src/stm32f10x_usart.c ****   *   - TC flag can be also cleared by software sequence: a read operation to 
 917:../SPL/src/stm32f10x_usart.c ****   *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
 918:../SPL/src/stm32f10x_usart.c ****   *     to USART_DR register (USART_SendData()).
 919:../SPL/src/stm32f10x_usart.c ****   *   - TXE flag is cleared only by a write to the USART_DR register 
 920:../SPL/src/stm32f10x_usart.c ****   *     (USART_SendData()).
 921:../SPL/src/stm32f10x_usart.c ****   * @retval None
 922:../SPL/src/stm32f10x_usart.c ****   */
 923:../SPL/src/stm32f10x_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
 924:../SPL/src/stm32f10x_usart.c **** {
 3124              		.loc 1 924 0
 3125              		.cfi_startproc
 3126              		@ args = 0, pretend = 0, frame = 8
 3127              		@ frame_needed = 1, uses_anonymous_args = 0
 3128 1294 80B5     		push	{r7, lr}
 3129              	.LCFI78:
 3130              		.cfi_def_cfa_offset 8
 3131              		.cfi_offset 7, -8
 3132              		.cfi_offset 14, -4
 3133 1296 82B0     		sub	sp, sp, #8
 3134              	.LCFI79:
 3135              		.cfi_def_cfa_offset 16
 3136 1298 00AF     		add	r7, sp, #0
 3137              	.LCFI80:
 3138              		.cfi_def_cfa_register 7
 3139 129a 7860     		str	r0, [r7, #4]
 3140 129c 0B46     		mov	r3, r1
 3141 129e 7B80     		strh	r3, [r7, #2]	@ movhi
 925:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 926:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 3142              		.loc 1 926 0
 3143 12a0 7A68     		ldr	r2, [r7, #4]
 3144 12a2 234B     		ldr	r3, .L181
 3145 12a4 9A42     		cmp	r2, r3
 3146 12a6 14D0     		beq	.L177
 3147              		.loc 1 926 0 is_stmt 0 discriminator 1
 3148 12a8 7A68     		ldr	r2, [r7, #4]
 3149 12aa 224B     		ldr	r3, .L181+4
 3150 12ac 9A42     		cmp	r2, r3
 3151 12ae 10D0     		beq	.L177
 3152              		.loc 1 926 0 discriminator 2
 3153 12b0 7A68     		ldr	r2, [r7, #4]
 3154 12b2 214B     		ldr	r3, .L181+8
 3155 12b4 9A42     		cmp	r2, r3
 3156 12b6 0CD0     		beq	.L177
 3157              		.loc 1 926 0 discriminator 3
 3158 12b8 7A68     		ldr	r2, [r7, #4]
 3159 12ba 204B     		ldr	r3, .L181+12
 3160 12bc 9A42     		cmp	r2, r3
 3161 12be 08D0     		beq	.L177
 3162              		.loc 1 926 0 discriminator 4
 3163 12c0 7A68     		ldr	r2, [r7, #4]
 3164 12c2 1F4B     		ldr	r3, .L181+16
 3165 12c4 9A42     		cmp	r2, r3
 3166 12c6 04D0     		beq	.L177
 3167              		.loc 1 926 0 discriminator 5
 3168 12c8 1E48     		ldr	r0, .L181+20
 3169 12ca 40F29E31 		movw	r1, #926
 3170 12ce FFF7FEFF 		bl	assert_failed
 3171              	.L177:
 927:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
 3172              		.loc 1 927 0 is_stmt 1
 3173 12d2 7A88     		ldrh	r2, [r7, #2]
 3174 12d4 4FF69F43 		movw	r3, #64671
 3175 12d8 1340     		ands	r3, r3, r2
 3176 12da 002B     		cmp	r3, #0
 3177 12dc 02D1     		bne	.L178
 3178              		.loc 1 927 0 is_stmt 0 discriminator 2
 3179 12de 7B88     		ldrh	r3, [r7, #2]
 3180 12e0 002B     		cmp	r3, #0
 3181 12e2 04D1     		bne	.L179
 3182              	.L178:
 3183              		.loc 1 927 0 discriminator 1
 3184 12e4 1748     		ldr	r0, .L181+20
 3185 12e6 40F29F31 		movw	r1, #927
 3186 12ea FFF7FEFF 		bl	assert_failed
 3187              	.L179:
 928:../SPL/src/stm32f10x_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
 929:../SPL/src/stm32f10x_usart.c ****   if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
 3188              		.loc 1 929 0 is_stmt 1
 3189 12ee 7B88     		ldrh	r3, [r7, #2]
 3190 12f0 03F40073 		and	r3, r3, #512
 3191 12f4 002B     		cmp	r3, #0
 3192 12f6 10D0     		beq	.L180
 930:../SPL/src/stm32f10x_usart.c ****   {
 931:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 3193              		.loc 1 931 0
 3194 12f8 7A68     		ldr	r2, [r7, #4]
 3195 12fa 0D4B     		ldr	r3, .L181
 3196 12fc 9A42     		cmp	r2, r3
 3197 12fe 0CD0     		beq	.L180
 3198              		.loc 1 931 0 is_stmt 0 discriminator 1
 3199 1300 7A68     		ldr	r2, [r7, #4]
 3200 1302 0C4B     		ldr	r3, .L181+4
 3201 1304 9A42     		cmp	r2, r3
 3202 1306 08D0     		beq	.L180
 3203              		.loc 1 931 0 discriminator 2
 3204 1308 7A68     		ldr	r2, [r7, #4]
 3205 130a 0B4B     		ldr	r3, .L181+8
 3206 130c 9A42     		cmp	r2, r3
 3207 130e 04D0     		beq	.L180
 3208              		.loc 1 931 0 discriminator 3
 3209 1310 0C48     		ldr	r0, .L181+20
 3210 1312 40F2A331 		movw	r1, #931
 3211 1316 FFF7FEFF 		bl	assert_failed
 3212              	.L180:
 932:../SPL/src/stm32f10x_usart.c ****   } 
 933:../SPL/src/stm32f10x_usart.c ****    
 934:../SPL/src/stm32f10x_usart.c ****   USARTx->SR = (uint16_t)~USART_FLAG;
 3213              		.loc 1 934 0 is_stmt 1
 3214 131a 7B88     		ldrh	r3, [r7, #2]	@ movhi
 3215 131c 6FEA0303 		mvn	r3, r3
 3216 1320 9AB2     		uxth	r2, r3
 3217 1322 7B68     		ldr	r3, [r7, #4]
 3218 1324 1A80     		strh	r2, [r3, #0]	@ movhi
 935:../SPL/src/stm32f10x_usart.c **** }
 3219              		.loc 1 935 0
 3220 1326 07F10807 		add	r7, r7, #8
 3221 132a BD46     		mov	sp, r7
 3222 132c 80BD     		pop	{r7, pc}
 3223              	.L182:
 3224 132e 00BF     		.align	2
 3225              	.L181:
 3226 1330 00380140 		.word	1073821696
 3227 1334 00440040 		.word	1073759232
 3228 1338 00480040 		.word	1073760256
 3229 133c 004C0040 		.word	1073761280
 3230 1340 00500040 		.word	1073762304
 3231 1344 00000000 		.word	.LC0
 3232              		.cfi_endproc
 3233              	.LFE55:
 3235              		.align	2
 3236              		.global	USART_GetITStatus
 3237              		.thumb
 3238              		.thumb_func
 3240              	USART_GetITStatus:
 3241              	.LFB56:
 936:../SPL/src/stm32f10x_usart.c **** 
 937:../SPL/src/stm32f10x_usart.c **** /**
 938:../SPL/src/stm32f10x_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
 939:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 940:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 941:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 942:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
 943:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 944:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
 945:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_LBD:  LIN Break detection interrupt
 946:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
 947:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TC:   Transmission complete interrupt
 948:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
 949:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_IDLE: Idle line detection interrupt
 950:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_ORE:  OverRun Error interrupt
 951:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_NE:   Noise Error interrupt
 952:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_FE:   Framing Error interrupt
 953:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_PE:   Parity Error interrupt
 954:../SPL/src/stm32f10x_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
 955:../SPL/src/stm32f10x_usart.c ****   */
 956:../SPL/src/stm32f10x_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
 957:../SPL/src/stm32f10x_usart.c **** {
 3242              		.loc 1 957 0
 3243              		.cfi_startproc
 3244              		@ args = 0, pretend = 0, frame = 24
 3245              		@ frame_needed = 1, uses_anonymous_args = 0
 3246 1348 80B5     		push	{r7, lr}
 3247              	.LCFI81:
 3248              		.cfi_def_cfa_offset 8
 3249              		.cfi_offset 7, -8
 3250              		.cfi_offset 14, -4
 3251 134a 86B0     		sub	sp, sp, #24
 3252              	.LCFI82:
 3253              		.cfi_def_cfa_offset 32
 3254 134c 00AF     		add	r7, sp, #0
 3255              	.LCFI83:
 3256              		.cfi_def_cfa_register 7
 3257 134e 7860     		str	r0, [r7, #4]
 3258 1350 0B46     		mov	r3, r1
 3259 1352 7B80     		strh	r3, [r7, #2]	@ movhi
 958:../SPL/src/stm32f10x_usart.c ****   uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 3260              		.loc 1 958 0
 3261 1354 4FF00003 		mov	r3, #0
 3262 1358 FB60     		str	r3, [r7, #12]
 3263 135a 4FF00003 		mov	r3, #0
 3264 135e 7B61     		str	r3, [r7, #20]
 3265 1360 4FF00003 		mov	r3, #0
 3266 1364 BB60     		str	r3, [r7, #8]
 959:../SPL/src/stm32f10x_usart.c ****   ITStatus bitstatus = RESET;
 3267              		.loc 1 959 0
 3268 1366 4FF00003 		mov	r3, #0
 3269 136a FB74     		strb	r3, [r7, #19]
 960:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 961:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 3270              		.loc 1 961 0
 3271 136c 7A68     		ldr	r2, [r7, #4]
 3272 136e 574B     		ldr	r3, .L193
 3273 1370 9A42     		cmp	r2, r3
 3274 1372 14D0     		beq	.L184
 3275              		.loc 1 961 0 is_stmt 0 discriminator 1
 3276 1374 7A68     		ldr	r2, [r7, #4]
 3277 1376 564B     		ldr	r3, .L193+4
 3278 1378 9A42     		cmp	r2, r3
 3279 137a 10D0     		beq	.L184
 3280              		.loc 1 961 0 discriminator 2
 3281 137c 7A68     		ldr	r2, [r7, #4]
 3282 137e 554B     		ldr	r3, .L193+8
 3283 1380 9A42     		cmp	r2, r3
 3284 1382 0CD0     		beq	.L184
 3285              		.loc 1 961 0 discriminator 3
 3286 1384 7A68     		ldr	r2, [r7, #4]
 3287 1386 544B     		ldr	r3, .L193+12
 3288 1388 9A42     		cmp	r2, r3
 3289 138a 08D0     		beq	.L184
 3290              		.loc 1 961 0 discriminator 4
 3291 138c 7A68     		ldr	r2, [r7, #4]
 3292 138e 534B     		ldr	r3, .L193+16
 3293 1390 9A42     		cmp	r2, r3
 3294 1392 04D0     		beq	.L184
 3295              		.loc 1 961 0 discriminator 5
 3296 1394 5248     		ldr	r0, .L193+20
 3297 1396 40F2C131 		movw	r1, #961
 3298 139a FFF7FEFF 		bl	assert_failed
 3299              	.L184:
 962:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT));
 3300              		.loc 1 962 0 is_stmt 1
 3301 139e 7B88     		ldrh	r3, [r7, #2]
 3302 13a0 282B     		cmp	r3, #40
 3303 13a2 2ED0     		beq	.L185
 3304              		.loc 1 962 0 is_stmt 0 discriminator 1
 3305 13a4 7A88     		ldrh	r2, [r7, #2]
 3306 13a6 40F22773 		movw	r3, #1831
 3307 13aa 9A42     		cmp	r2, r3
 3308 13ac 29D0     		beq	.L185
 3309              		.loc 1 962 0 discriminator 2
 3310 13ae 7A88     		ldrh	r2, [r7, #2]
 3311 13b0 40F22663 		movw	r3, #1574
 3312 13b4 9A42     		cmp	r2, r3
 3313 13b6 24D0     		beq	.L185
 3314              		.loc 1 962 0 discriminator 3
 3315 13b8 7A88     		ldrh	r2, [r7, #2]
 3316 13ba 40F22553 		movw	r3, #1317
 3317 13be 9A42     		cmp	r2, r3
 3318 13c0 1FD0     		beq	.L185
 3319              		.loc 1 962 0 discriminator 4
 3320 13c2 7A88     		ldrh	r2, [r7, #2]
 3321 13c4 40F22443 		movw	r3, #1060
 3322 13c8 9A42     		cmp	r2, r3
 3323 13ca 1AD0     		beq	.L185
 3324              		.loc 1 962 0 discriminator 5
 3325 13cc 7A88     		ldrh	r2, [r7, #2]
 3326 13ce 40F64603 		movw	r3, #2118
 3327 13d2 9A42     		cmp	r2, r3
 3328 13d4 15D0     		beq	.L185
 3329              		.loc 1 962 0 discriminator 6
 3330 13d6 7A88     		ldrh	r2, [r7, #2]
 3331 13d8 40F66A13 		movw	r3, #2410
 3332 13dc 9A42     		cmp	r2, r3
 3333 13de 10D0     		beq	.L185
 3334              		.loc 1 962 0 discriminator 7
 3335 13e0 7B88     		ldrh	r3, [r7, #2]
 3336 13e2 B3F5587F 		cmp	r3, #864
 3337 13e6 0CD0     		beq	.L185
 3338              		.loc 1 962 0 discriminator 8
 3339 13e8 7B88     		ldrh	r3, [r7, #2]
 3340 13ea B3F5187F 		cmp	r3, #608
 3341 13ee 08D0     		beq	.L185
 3342              		.loc 1 962 0 discriminator 9
 3343 13f0 7B88     		ldrh	r3, [r7, #2]
 3344 13f2 B3F5B07F 		cmp	r3, #352
 3345 13f6 04D0     		beq	.L185
 3346              		.loc 1 962 0 discriminator 10
 3347 13f8 3948     		ldr	r0, .L193+20
 3348 13fa 40F2C231 		movw	r1, #962
 3349 13fe FFF7FEFF 		bl	assert_failed
 3350              	.L185:
 963:../SPL/src/stm32f10x_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */ 
 964:../SPL/src/stm32f10x_usart.c ****   if (USART_IT == USART_IT_CTS)
 3351              		.loc 1 964 0 is_stmt 1
 3352 1402 7A88     		ldrh	r2, [r7, #2]
 3353 1404 40F66A13 		movw	r3, #2410
 3354 1408 9A42     		cmp	r2, r3
 3355 140a 10D1     		bne	.L186
 965:../SPL/src/stm32f10x_usart.c ****   {
 966:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 3356              		.loc 1 966 0
 3357 140c 7A68     		ldr	r2, [r7, #4]
 3358 140e 2F4B     		ldr	r3, .L193
 3359 1410 9A42     		cmp	r2, r3
 3360 1412 0CD0     		beq	.L186
 3361              		.loc 1 966 0 is_stmt 0 discriminator 1
 3362 1414 7A68     		ldr	r2, [r7, #4]
 3363 1416 2E4B     		ldr	r3, .L193+4
 3364 1418 9A42     		cmp	r2, r3
 3365 141a 08D0     		beq	.L186
 3366              		.loc 1 966 0 discriminator 2
 3367 141c 7A68     		ldr	r2, [r7, #4]
 3368 141e 2D4B     		ldr	r3, .L193+8
 3369 1420 9A42     		cmp	r2, r3
 3370 1422 04D0     		beq	.L186
 3371              		.loc 1 966 0 discriminator 3
 3372 1424 2E48     		ldr	r0, .L193+20
 3373 1426 40F2C631 		movw	r1, #966
 3374 142a FFF7FEFF 		bl	assert_failed
 3375              	.L186:
 967:../SPL/src/stm32f10x_usart.c ****   }   
 968:../SPL/src/stm32f10x_usart.c ****   
 969:../SPL/src/stm32f10x_usart.c ****   /* Get the USART register index */
 970:../SPL/src/stm32f10x_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 3376              		.loc 1 970 0 is_stmt 1
 3377 142e 7B88     		ldrh	r3, [r7, #2]	@ movhi
 3378 1430 DBB2     		uxtb	r3, r3
 3379 1432 4FEA5313 		lsr	r3, r3, #5
 3380 1436 DBB2     		uxtb	r3, r3
 3381 1438 BB60     		str	r3, [r7, #8]
 971:../SPL/src/stm32f10x_usart.c ****   /* Get the interrupt position */
 972:../SPL/src/stm32f10x_usart.c ****   itmask = USART_IT & IT_Mask;
 3382              		.loc 1 972 0
 3383 143a 7B88     		ldrh	r3, [r7, #2]
 3384 143c 03F01F03 		and	r3, r3, #31
 3385 1440 7B61     		str	r3, [r7, #20]
 973:../SPL/src/stm32f10x_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 3386              		.loc 1 973 0
 3387 1442 7B69     		ldr	r3, [r7, #20]
 3388 1444 4FF00102 		mov	r2, #1
 3389 1448 02FA03F3 		lsl	r3, r2, r3
 3390 144c 7B61     		str	r3, [r7, #20]
 974:../SPL/src/stm32f10x_usart.c ****   
 975:../SPL/src/stm32f10x_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 3391              		.loc 1 975 0
 3392 144e BB68     		ldr	r3, [r7, #8]
 3393 1450 012B     		cmp	r3, #1
 3394 1452 06D1     		bne	.L187
 976:../SPL/src/stm32f10x_usart.c ****   {
 977:../SPL/src/stm32f10x_usart.c ****     itmask &= USARTx->CR1;
 3395              		.loc 1 977 0
 3396 1454 7B68     		ldr	r3, [r7, #4]
 3397 1456 9B89     		ldrh	r3, [r3, #12]	@ movhi
 3398 1458 9BB2     		uxth	r3, r3
 3399 145a 7A69     		ldr	r2, [r7, #20]
 3400 145c 1340     		ands	r3, r3, r2
 3401 145e 7B61     		str	r3, [r7, #20]
 3402 1460 0FE0     		b	.L188
 3403              	.L187:
 978:../SPL/src/stm32f10x_usart.c ****   }
 979:../SPL/src/stm32f10x_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 3404              		.loc 1 979 0
 3405 1462 BB68     		ldr	r3, [r7, #8]
 3406 1464 022B     		cmp	r3, #2
 3407 1466 06D1     		bne	.L189
 980:../SPL/src/stm32f10x_usart.c ****   {
 981:../SPL/src/stm32f10x_usart.c ****     itmask &= USARTx->CR2;
 3408              		.loc 1 981 0
 3409 1468 7B68     		ldr	r3, [r7, #4]
 3410 146a 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 3411 146c 9BB2     		uxth	r3, r3
 3412 146e 7A69     		ldr	r2, [r7, #20]
 3413 1470 1340     		ands	r3, r3, r2
 3414 1472 7B61     		str	r3, [r7, #20]
 3415 1474 05E0     		b	.L188
 3416              	.L189:
 982:../SPL/src/stm32f10x_usart.c ****   }
 983:../SPL/src/stm32f10x_usart.c ****   else /* The IT  is in CR3 register */
 984:../SPL/src/stm32f10x_usart.c ****   {
 985:../SPL/src/stm32f10x_usart.c ****     itmask &= USARTx->CR3;
 3417              		.loc 1 985 0
 3418 1476 7B68     		ldr	r3, [r7, #4]
 3419 1478 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 3420 147a 9BB2     		uxth	r3, r3
 3421 147c 7A69     		ldr	r2, [r7, #20]
 3422 147e 1340     		ands	r3, r3, r2
 3423 1480 7B61     		str	r3, [r7, #20]
 3424              	.L188:
 986:../SPL/src/stm32f10x_usart.c ****   }
 987:../SPL/src/stm32f10x_usart.c ****   
 988:../SPL/src/stm32f10x_usart.c ****   bitpos = USART_IT >> 0x08;
 3425              		.loc 1 988 0
 3426 1482 7B88     		ldrh	r3, [r7, #2]
 3427 1484 4FEA1323 		lsr	r3, r3, #8
 3428 1488 9BB2     		uxth	r3, r3
 3429 148a FB60     		str	r3, [r7, #12]
 989:../SPL/src/stm32f10x_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 3430              		.loc 1 989 0
 3431 148c FB68     		ldr	r3, [r7, #12]
 3432 148e 4FF00102 		mov	r2, #1
 3433 1492 02FA03F3 		lsl	r3, r2, r3
 3434 1496 FB60     		str	r3, [r7, #12]
 990:../SPL/src/stm32f10x_usart.c ****   bitpos &= USARTx->SR;
 3435              		.loc 1 990 0
 3436 1498 7B68     		ldr	r3, [r7, #4]
 3437 149a 1B88     		ldrh	r3, [r3, #0]	@ movhi
 3438 149c 9BB2     		uxth	r3, r3
 3439 149e FA68     		ldr	r2, [r7, #12]
 3440 14a0 1340     		ands	r3, r3, r2
 3441 14a2 FB60     		str	r3, [r7, #12]
 991:../SPL/src/stm32f10x_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 3442              		.loc 1 991 0
 3443 14a4 7B69     		ldr	r3, [r7, #20]
 3444 14a6 002B     		cmp	r3, #0
 3445 14a8 06D0     		beq	.L190
 3446              		.loc 1 991 0 is_stmt 0 discriminator 1
 3447 14aa FB68     		ldr	r3, [r7, #12]
 3448 14ac 002B     		cmp	r3, #0
 3449 14ae 03D0     		beq	.L190
 992:../SPL/src/stm32f10x_usart.c ****   {
 993:../SPL/src/stm32f10x_usart.c ****     bitstatus = SET;
 3450              		.loc 1 993 0 is_stmt 1
 3451 14b0 4FF00103 		mov	r3, #1
 3452 14b4 FB74     		strb	r3, [r7, #19]
 3453 14b6 02E0     		b	.L191
 3454              	.L190:
 994:../SPL/src/stm32f10x_usart.c ****   }
 995:../SPL/src/stm32f10x_usart.c ****   else
 996:../SPL/src/stm32f10x_usart.c ****   {
 997:../SPL/src/stm32f10x_usart.c ****     bitstatus = RESET;
 3455              		.loc 1 997 0
 3456 14b8 4FF00003 		mov	r3, #0
 3457 14bc FB74     		strb	r3, [r7, #19]
 3458              	.L191:
 998:../SPL/src/stm32f10x_usart.c ****   }
 999:../SPL/src/stm32f10x_usart.c ****   
1000:../SPL/src/stm32f10x_usart.c ****   return bitstatus;  
 3459              		.loc 1 1000 0
 3460 14be FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
1001:../SPL/src/stm32f10x_usart.c **** }
 3461              		.loc 1 1001 0
 3462 14c0 1846     		mov	r0, r3
 3463 14c2 07F11807 		add	r7, r7, #24
 3464 14c6 BD46     		mov	sp, r7
 3465 14c8 80BD     		pop	{r7, pc}
 3466              	.L194:
 3467 14ca 00BF     		.align	2
 3468              	.L193:
 3469 14cc 00380140 		.word	1073821696
 3470 14d0 00440040 		.word	1073759232
 3471 14d4 00480040 		.word	1073760256
 3472 14d8 004C0040 		.word	1073761280
 3473 14dc 00500040 		.word	1073762304
 3474 14e0 00000000 		.word	.LC0
 3475              		.cfi_endproc
 3476              	.LFE56:
 3478              		.align	2
 3479              		.global	USART_ClearITPendingBit
 3480              		.thumb
 3481              		.thumb_func
 3483              	USART_ClearITPendingBit:
 3484              	.LFB57:
1002:../SPL/src/stm32f10x_usart.c **** 
1003:../SPL/src/stm32f10x_usart.c **** /**
1004:../SPL/src/stm32f10x_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
1005:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
1006:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
1007:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
1008:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
1009:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
1010:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1011:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_LBD:  LIN Break detection interrupt
1012:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TC:   Transmission complete interrupt. 
1013:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.
1014:../SPL/src/stm32f10x_usart.c ****   *   
1015:../SPL/src/stm32f10x_usart.c ****   * @note
1016:../SPL/src/stm32f10x_usart.c ****   *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1017:../SPL/src/stm32f10x_usart.c ****   *     error) and IDLE (Idle line detected) pending bits are cleared by 
1018:../SPL/src/stm32f10x_usart.c ****   *     software sequence: a read operation to USART_SR register 
1019:../SPL/src/stm32f10x_usart.c ****   *     (USART_GetITStatus()) followed by a read operation to USART_DR register 
1020:../SPL/src/stm32f10x_usart.c ****   *     (USART_ReceiveData()).
1021:../SPL/src/stm32f10x_usart.c ****   *   - RXNE pending bit can be also cleared by a read to the USART_DR register 
1022:../SPL/src/stm32f10x_usart.c ****   *     (USART_ReceiveData()).
1023:../SPL/src/stm32f10x_usart.c ****   *   - TC pending bit can be also cleared by software sequence: a read 
1024:../SPL/src/stm32f10x_usart.c ****   *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
1025:../SPL/src/stm32f10x_usart.c ****   *     operation to USART_DR register (USART_SendData()).
1026:../SPL/src/stm32f10x_usart.c ****   *   - TXE pending bit is cleared only by a write to the USART_DR register 
1027:../SPL/src/stm32f10x_usart.c ****   *     (USART_SendData()).
1028:../SPL/src/stm32f10x_usart.c ****   * @retval None
1029:../SPL/src/stm32f10x_usart.c ****   */
1030:../SPL/src/stm32f10x_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
1031:../SPL/src/stm32f10x_usart.c **** {
 3485              		.loc 1 1031 0
 3486              		.cfi_startproc
 3487              		@ args = 0, pretend = 0, frame = 16
 3488              		@ frame_needed = 1, uses_anonymous_args = 0
 3489 14e4 80B5     		push	{r7, lr}
 3490              	.LCFI84:
 3491              		.cfi_def_cfa_offset 8
 3492              		.cfi_offset 7, -8
 3493              		.cfi_offset 14, -4
 3494 14e6 84B0     		sub	sp, sp, #16
 3495              	.LCFI85:
 3496              		.cfi_def_cfa_offset 24
 3497 14e8 00AF     		add	r7, sp, #0
 3498              	.LCFI86:
 3499              		.cfi_def_cfa_register 7
 3500 14ea 7860     		str	r0, [r7, #4]
 3501 14ec 0B46     		mov	r3, r1
 3502 14ee 7B80     		strh	r3, [r7, #2]	@ movhi
1032:../SPL/src/stm32f10x_usart.c ****   uint16_t bitpos = 0x00, itmask = 0x00;
 3503              		.loc 1 1032 0
 3504 14f0 4FF00003 		mov	r3, #0
 3505 14f4 FB81     		strh	r3, [r7, #14]	@ movhi
 3506 14f6 4FF00003 		mov	r3, #0
 3507 14fa BB81     		strh	r3, [r7, #12]	@ movhi
1033:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
1034:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 3508              		.loc 1 1034 0
 3509 14fc 7A68     		ldr	r2, [r7, #4]
 3510 14fe 2D4B     		ldr	r3, .L199
 3511 1500 9A42     		cmp	r2, r3
 3512 1502 14D0     		beq	.L196
 3513              		.loc 1 1034 0 is_stmt 0 discriminator 1
 3514 1504 7A68     		ldr	r2, [r7, #4]
 3515 1506 2C4B     		ldr	r3, .L199+4
 3516 1508 9A42     		cmp	r2, r3
 3517 150a 10D0     		beq	.L196
 3518              		.loc 1 1034 0 discriminator 2
 3519 150c 7A68     		ldr	r2, [r7, #4]
 3520 150e 2B4B     		ldr	r3, .L199+8
 3521 1510 9A42     		cmp	r2, r3
 3522 1512 0CD0     		beq	.L196
 3523              		.loc 1 1034 0 discriminator 3
 3524 1514 7A68     		ldr	r2, [r7, #4]
 3525 1516 2A4B     		ldr	r3, .L199+12
 3526 1518 9A42     		cmp	r2, r3
 3527 151a 08D0     		beq	.L196
 3528              		.loc 1 1034 0 discriminator 4
 3529 151c 7A68     		ldr	r2, [r7, #4]
 3530 151e 294B     		ldr	r3, .L199+16
 3531 1520 9A42     		cmp	r2, r3
 3532 1522 04D0     		beq	.L196
 3533              		.loc 1 1034 0 discriminator 5
 3534 1524 2848     		ldr	r0, .L199+20
 3535 1526 40F20A41 		movw	r1, #1034
 3536 152a FFF7FEFF 		bl	assert_failed
 3537              	.L196:
1035:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT));
 3538              		.loc 1 1035 0 is_stmt 1
 3539 152e 7A88     		ldrh	r2, [r7, #2]
 3540 1530 40F22663 		movw	r3, #1574
 3541 1534 9A42     		cmp	r2, r3
 3542 1536 13D0     		beq	.L197
 3543              		.loc 1 1035 0 is_stmt 0 discriminator 1
 3544 1538 7A88     		ldrh	r2, [r7, #2]
 3545 153a 40F22553 		movw	r3, #1317
 3546 153e 9A42     		cmp	r2, r3
 3547 1540 0ED0     		beq	.L197
 3548              		.loc 1 1035 0 discriminator 2
 3549 1542 7A88     		ldrh	r2, [r7, #2]
 3550 1544 40F64603 		movw	r3, #2118
 3551 1548 9A42     		cmp	r2, r3
 3552 154a 09D0     		beq	.L197
 3553              		.loc 1 1035 0 discriminator 3
 3554 154c 7A88     		ldrh	r2, [r7, #2]
 3555 154e 40F66A13 		movw	r3, #2410
 3556 1552 9A42     		cmp	r2, r3
 3557 1554 04D0     		beq	.L197
 3558              		.loc 1 1035 0 discriminator 4
 3559 1556 1C48     		ldr	r0, .L199+20
 3560 1558 40F20B41 		movw	r1, #1035
 3561 155c FFF7FEFF 		bl	assert_failed
 3562              	.L197:
1036:../SPL/src/stm32f10x_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1037:../SPL/src/stm32f10x_usart.c ****   if (USART_IT == USART_IT_CTS)
 3563              		.loc 1 1037 0 is_stmt 1
 3564 1560 7A88     		ldrh	r2, [r7, #2]
 3565 1562 40F66A13 		movw	r3, #2410
 3566 1566 9A42     		cmp	r2, r3
 3567 1568 10D1     		bne	.L198
1038:../SPL/src/stm32f10x_usart.c ****   {
1039:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 3568              		.loc 1 1039 0
 3569 156a 7A68     		ldr	r2, [r7, #4]
 3570 156c 114B     		ldr	r3, .L199
 3571 156e 9A42     		cmp	r2, r3
 3572 1570 0CD0     		beq	.L198
 3573              		.loc 1 1039 0 is_stmt 0 discriminator 1
 3574 1572 7A68     		ldr	r2, [r7, #4]
 3575 1574 104B     		ldr	r3, .L199+4
 3576 1576 9A42     		cmp	r2, r3
 3577 1578 08D0     		beq	.L198
 3578              		.loc 1 1039 0 discriminator 2
 3579 157a 7A68     		ldr	r2, [r7, #4]
 3580 157c 0F4B     		ldr	r3, .L199+8
 3581 157e 9A42     		cmp	r2, r3
 3582 1580 04D0     		beq	.L198
 3583              		.loc 1 1039 0 discriminator 3
 3584 1582 1148     		ldr	r0, .L199+20
 3585 1584 40F20F41 		movw	r1, #1039
 3586 1588 FFF7FEFF 		bl	assert_failed
 3587              	.L198:
1040:../SPL/src/stm32f10x_usart.c ****   }   
1041:../SPL/src/stm32f10x_usart.c ****   
1042:../SPL/src/stm32f10x_usart.c ****   bitpos = USART_IT >> 0x08;
 3588              		.loc 1 1042 0 is_stmt 1
 3589 158c 7B88     		ldrh	r3, [r7, #2]
 3590 158e 4FEA1323 		lsr	r3, r3, #8
 3591 1592 FB81     		strh	r3, [r7, #14]	@ movhi
1043:../SPL/src/stm32f10x_usart.c ****   itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 3592              		.loc 1 1043 0
 3593 1594 FB89     		ldrh	r3, [r7, #14]
 3594 1596 4FF00102 		mov	r2, #1
 3595 159a 02FA03F3 		lsl	r3, r2, r3
 3596 159e BB81     		strh	r3, [r7, #12]	@ movhi
1044:../SPL/src/stm32f10x_usart.c ****   USARTx->SR = (uint16_t)~itmask;
 3597              		.loc 1 1044 0
 3598 15a0 BB89     		ldrh	r3, [r7, #12]	@ movhi
 3599 15a2 6FEA0303 		mvn	r3, r3
 3600 15a6 9AB2     		uxth	r2, r3
 3601 15a8 7B68     		ldr	r3, [r7, #4]
 3602 15aa 1A80     		strh	r2, [r3, #0]	@ movhi
1045:../SPL/src/stm32f10x_usart.c **** }
 3603              		.loc 1 1045 0
 3604 15ac 07F11007 		add	r7, r7, #16
 3605 15b0 BD46     		mov	sp, r7
 3606 15b2 80BD     		pop	{r7, pc}
 3607              	.L200:
 3608              		.align	2
 3609              	.L199:
 3610 15b4 00380140 		.word	1073821696
 3611 15b8 00440040 		.word	1073759232
 3612 15bc 00480040 		.word	1073760256
 3613 15c0 004C0040 		.word	1073761280
 3614 15c4 00500040 		.word	1073762304
 3615 15c8 00000000 		.word	.LC0
 3616              		.cfi_endproc
 3617              	.LFE57:
 3619              	.Letext0:
 3620              		.file 2 "c:\\program files (x86)\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/
 3621              		.file 3 "C:\\Users\\PC108\\Export_project\\stm32_ld_vl\\CMSIS/stm32f10x.h"
 3622              		.file 4 "C:\\Users\\PC108\\Export_project\\stm32_ld_vl\\SPL\\inc/stm32f10x_rcc.h"
 3623              		.file 5 "C:\\Users\\PC108\\Export_project\\stm32_ld_vl\\SPL\\inc/stm32f10x_usart.h"
 3624              		.file 6 "C:\\Users\\PC108\\Export_project\\stm32_ld_vl\\CMSIS/core_cm3.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f10x_usart.c
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:19     .rodata:00000000 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:23     .text:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:28     .text:00000000 USART_DeInit
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:158    .text:000000ec $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:167    .text:00000104 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:172    .text:00000104 USART_Init
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:548    .text:000003a4 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:558    .text:000003c4 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:581    .text:000003f4 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:585    .text:000003f8 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:590    .text:000003f8 USART_StructInit
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:645    .text:0000043c USART_ClockInit
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:789    .text:00000524 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:796    .text:00000534 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:801    .text:00000534 USART_ClockStructInit
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:848    .text:00000568 USART_Cmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:941    .text:000005ec $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:950    .text:00000604 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:955    .text:00000604 USART_ITConfig
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1170   .text:0000076c $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1179   .text:00000784 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1184   .text:00000784 USART_DMACmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1299   .text:00000830 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1308   .text:00000848 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1313   .text:00000848 USART_SetAddress
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1397   .text:000008c0 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1406   .text:000008d8 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1411   .text:000008d8 USART_WakeUpConfig
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1498   .text:00000958 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1507   .text:00000970 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1512   .text:00000970 USART_ReceiverWakeUpCmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1605   .text:000009f4 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1614   .text:00000a0c $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1619   .text:00000a0c USART_LINBreakDetectLengthConfig
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1706   .text:00000a88 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1715   .text:00000aa0 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1720   .text:00000aa0 USART_LINCmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1813   .text:00000b24 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1822   .text:00000b3c $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1827   .text:00000b3c USART_SendData
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1901   .text:00000ba8 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1910   .text:00000bc0 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1915   .text:00000bc0 USART_ReceiveData
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1978   .text:00000c14 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1987   .text:00000c2c $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:1992   .text:00000c2c USART_SendBreak
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2055   .text:00000c80 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2064   .text:00000c98 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2069   .text:00000c98 USART_SetGuardTime
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2136   .text:00000cf4 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2143   .text:00000d04 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2148   .text:00000d04 USART_SetPrescaler
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2223   .text:00000d6c $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2232   .text:00000d84 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2237   .text:00000d84 USART_SmartCardCmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2320   .text:00000df8 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2327   .text:00000e08 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2332   .text:00000e08 USART_SmartCardNACKCmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2415   .text:00000e7c $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2422   .text:00000e8c $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2427   .text:00000e8c USART_HalfDuplexCmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2520   .text:00000f10 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2529   .text:00000f28 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2534   .text:00000f28 USART_OverSampling8Cmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2629   .text:00000fb4 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2638   .text:00000fcc $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2643   .text:00000fcc USART_OneBitMethodCmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2736   .text:00001050 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2745   .text:00001068 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2750   .text:00001068 USART_IrDAConfig
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2837   .text:000010e4 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2846   .text:000010fc $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2851   .text:000010fc USART_IrDACmd
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2944   .text:00001180 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2953   .text:00001198 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:2958   .text:00001198 USART_GetFlagStatus
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3108   .text:0000127c $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3117   .text:00001294 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3122   .text:00001294 USART_ClearFlag
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3226   .text:00001330 $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3235   .text:00001348 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3240   .text:00001348 USART_GetITStatus
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3469   .text:000014cc $d
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3478   .text:000014e4 $t
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3483   .text:000014e4 USART_ClearITPendingBit
C:\Users\PC108\AppData\Local\Temp\ccXd8BIg.s:3610   .text:000015b4 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.9001f459856fa07d79ce9793bb17c6cd
                           .group:00000000 wm4.stm32f10x.h.51.b859cb68ed44ee02c916b41cb8c68f1c
                           .group:00000000 wm4.core_cm3.h.25.d35e9a9b04ec4aaebae9bf79fff061f9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cm3.h.113.b286929a54d33b4c8909a7132437b244
                           .group:00000000 wm4.stm32f10x.h.522.115ebb8291fa96f8c9e0b9a9b670f703
                           .group:00000000 wm4.stm32f10x_exti.h.56.8b2f216f9ded9d03a9eb42ed6973fc04
                           .group:00000000 wm4.stm32f10x_gpio.h.25.80c981af0e637567395034c576cfb3ce
                           .group:00000000 wm4.stm32f10x_rcc.h.25.fe8897e7491f2eb0cff54551d08eb765
                           .group:00000000 wm4.stm32f10x_tim.h.25.21c6ec062f1e74898cb96a57da276fec
                           .group:00000000 wm4.misc.h.25.068e106f368fa5369a681ef57c106f4b
                           .group:00000000 wm4.stm32f10x.h.8304.f7d8ad90959e99679b3257267c3aadfe
                           .group:00000000 wm4.stm32f10x_usart.h.107.8846ccd7e61ab380957a621cc3460139

UNDEFINED SYMBOLS
assert_failed
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
